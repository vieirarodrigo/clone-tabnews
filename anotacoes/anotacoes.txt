### Git e GitHub

# O que é Git?

O Git é um sistema de controle de versão distribuído, gratuito e de código aberto, que permite rastrear e gerenciar as alterações em um projeto de software ao longo do tempo. Ele foi criado por Linus Torvalds em 2005. O Git é uma ferramenta essencial para desenvolvedores, facilitando a colaboração em projetos, a criação de versões e a reversão de alterações caso necessário. 

O Git é como se fosse um vídeo no meu computador.

# O que é GitHub?

O GitHub é uma plataforma online que funciona como um grande repositório de código de programação, onde desenvolvedores podem armazenar, compartilhar e colaborar em projetos. É essencialmente uma rede social para programadores, facilitando o trabalho em equipe e a colaboração em projetos de código aberto. 

O GitHub é como o YouTube, uma plataforma que posso compartilhar ou assistir outros videos.

Para criar uma conta no GitHub: https://docs.github.com/pt/get-started/start-your-journey/creating-an-account-on-github

Para criar um repositório no GitHub: https://docs.github.com/pt/repositories/creating-and-managing-repositories/creating-a-new-repository

### Codespaces

# O que é codespaces?

Um codespace é um ambiente de desenvolvimento virtual e hospedado na nuvem, oferecido pelo GitHub. Permite que os desenvolvedores escrevam, testem e depurem código diretamente na nuvem, sem a necessidade de configurações locais complexas. 

Como criar um codespace para um repositório: https://docs.github.com/pt/codespaces/developing-in-a-codespace/creating-a-codespace-for-a-repository

### Atenção

Aprenda a função das coisas, não se preenda a gostos pessoais.

### Anotações pessoais

O Git é um controlador de versões, ele cria e gerencia várias versões do projeto. Ele faz uma cópia sempre que você o chama, não copiando totalmente, mas indicando as alterações que foram realizadas em cada versão.

O GitHub é uma rede social, no qual posso compartilhar projetos, acessar, editar, copiar e interagir com projetos de outras pessoas.

O codespaces é um espaço para eu desenvolver meus projetos, ele cria uma máquina virtual com o vscode e um terminal, no qual me permite desenvolver sem as limitações de um computador físico mais modesto.

### Referências:

https://www.atlassian.com/br/git/tutorials/what-is-git
https://docs.github.com/pt/get-startedstart-your-journey/about-github-and-git
https://docs.github.com/pt/codespaces/about-codespaces/what-are-codespaces

#################################

"Se você quiser fazer uma torta de maçã a partir do zero, você deve primeiro inventar o Universo." - Carl Sagan

Não é possível hoje começar algo do zero, vamos precisar subir no ombro de gigantes e alçar novos voos. Isso não é um problema, podemos fazer coisas incríveis em comunidade.

### Node.js

# O que é node.js

Node.js é um ambiente de execução JavaScript do lado do servidor, que permite aos desenvolvedores criar aplicações web, APIs, e outras ferramentas de linha de comando utilizando a linguagem JavaScript.

Node.js é como uma cozinha que permite preparar receitas (aplicações) usando um fogão (ambiente de execução) que entende a linguagem do JavaScript.

# Terminal 

Terminal é uma interface de linha de comando que permite interagir com um sistema operacional através de comandos digitados, sme a necissade de uma interface gráfica.

Terminal é como um pedaço de papel, ele permite que você intereja com o sistema operacional, enquanto o shell é o "motor" que interpreta e executa seus comandos.

# Shell

É uma interface que permite aos utilizadores interagir com um sistema operacional.

É como a casca de um ovo, que protege o conteúdo interno.

# NVM (Node Version Manager)

NVM é uma ferramenta que permite aos desenvolvedores gerenciar várias cersões do Node.js em um único sistema operacional.

# Para acessar os detalhes do NVM use:

nvm --help (node version manager ajuda)

### Como instalar uma versão específica do Node.js?

1º Vamos precisar listar as versões disponiveis,vamos usar o comando: 

nvm ls (node version manager list)

2º Escolha a versão, por exemplo lts/hydrogen, para isso use os comandos:

nvm install lts/hydrogen (node version manager install version)

### Como deixar a versão anterior como padrão

Para isso vamos precisar definir como padrão a versão deseja, conforme abaixo:

nvm alias default <version> (node version manager apelido padrão versão)

### Declarar a versão utilizada no projeto

Para deixar claro para outras pessoas e padronizar o projeto, precisamos deixar claro qual versão do node vai ser utilizado, fazemos isso da forma abaixo:

1º Crie o arquivo abaixo na pasta raiz do projeto.
.nvmrc (node version manager run commands)

2º Dentro escreva a versão desejada e pule uma linha.

Exemplo:
"
lts/hydrogen

"

### Next.js

É um framework React para construir aplicações web, que fornece uma estrutura e recursos extras para otimizar o desenvolvimento e melhorar o desempenho das aplicações.

É como um motor que facilita a construção de aplicações web com React.

Também para o Next e o React, é necessário indicar no projeto quais versões foram utilizadas. Para isso vamos:

1º Precisamos inicializar o node no nosso projeto e esse comando vai criar um arquivo package.json, usamos o comando:

npm init (node package manager initialize)

2º Vamos escolher a versão do next.js que será utilizado, nesse exemplo vamos usar a versão 13.1.6:

npm install next@13.1.6 (node package manager install <version>)

### React

É uma biblioteca JavaScript de software livre, popularmente utilizada para construir interfaces de usuário do lado do cliente (front-end).

É como um sistema de blocos de construção para interfaces de usuário, onde cada bloco (componente) pode ser utilizado e combinado para criar aplicações complexas.

É necessário instalar a versão do react, nesse exemplo é a 18.2.0:

npm install react@18.2.0 (node package install <version>)

O ponto é que o React foi separado entre seu core e suas renderizações, pois ele é extremamente vasto.

Para HTML, quem renderiza é o DOM, para isso vamos instalar a versão do react DOM, para manipula-lo:

npm install react-dom@18.2.0 (node package install <version>)






O que é um serviço web?

Protocolos

HTTP
FTP
SMTP
UDP
IP

UDP TCP

next dev
"dev": "next dev"


Ctrl + L

pages

index.js 

function Home() {
    return <h1>Teste</h1>
}

export default Home;

deploy



#################
Control History

Versionamento de código

sccs -> rcs -> cvs -> svn -> git
       centralizado        | distribuído

Merge

Merge conflict

Clone

ls -la

.git

Diff

Delta encoding

Blob

git log

Commit


3 estágios

1 - Modified
2 - Staged
3 - Commit

git log --stat

git status

Unstrack file

Build

.gitignore

git add nome do arquivo

git commit



git log --oneline

Working Directory

Diff

git diff

Newline

Amend

git commit --amend 

Gits são imutáveis












origin/main

branch

git push

pull

git commit -m "Mensagem"

git push --force ou --f







Continuos deployment

Client / Server


Hospedagem de site

Deploy

Continuos integration -> Build


Principle least privilege

Cada commit deployado, kkk, tem uma url unica









N1: Ser lembrado indivualmente; (Anotar tarefas no papel, em cima da mesa)
N2: Ser lembrado em grupo; (Quadro kambam)
N3: Expandir conhecimento; (Trello ou Github)
N4: Gerar metas. (Jira)


Issue inception

Milestones
    - Milestone 0: Em construção

Estágio 1 - Início
Estágio 2 - Progresso
Estágio 3 - Conclusão

Issues: 

Colocar o site num domínio .com.br
Definir estilização do código e configurar editor
Programar página de "Em construção"










Estilização de código é essencial

- [ ] - Ligar sincronização do editor
- [ ] - Configurar o EditorConfig
- [ ] - Configurar o Prettier


EditorConfig

.EditorConfig

root = true

[*] 
indent_style = space
indent_size = 2


Prettier / Standard js

npm install prettier -D ou --save-dev


no package.json
"lint:check": "prettier --check ."
"lint:fix": "prettier --write ."







DNS 2 - níveis

IP é o endereço de cada computador

DNS é um apelido

DNS <- Computador -> servidor
    ->

Recursive Resolver <- Computador
                    ->

Recursive Resolver -> Root Server
                   <-
                   -> TLD 
                   <-
                   -> Authoritative Server

FQDN

Root Domain - TLD - Authoritative Server - TTL
            ccTLD/gTLD












### Dia 12 - DNS (Prática)

Task da insue "Coloca o site num domínio .com.br"

- [ ] - Registrar domínio próprio
- [ ] - Configurar Servidor de DNS

Registrant -> Registrar -> Registry -> TLD

whatismydns -> NS

vieirarodrigo.com.br


Dizer para vercel o nosso domínio

Dizer para a TLD o nosso DNS


### Git e GitHub

# O que é Git?

O Git é um sistema de controle de versão distribuído, gratuito e de código aberto, que permite rastrear e gerenciar as alterações em um projeto de software ao longo do tempo. Ele foi criado por Linus Torvalds em 2005. O Git é uma ferramenta essencial para desenvolvedores, facilitando a colaboração em projetos, a criação de versões e a reversão de alterações caso necessário. 

O Git é como se fosse um vídeo no meu computador.

# O que é GitHub?

O GitHub é uma plataforma online que funciona como um grande repositório de código de programação, onde desenvolvedores podem armazenar, compartilhar e colaborar em projetos. É essencialmente uma rede social para programadores, facilitando o trabalho em equipe e a colaboração em projetos de código aberto. 

O GitHub é como o YouTube, uma plataforma que posso compartilhar ou assistir outros videos.

Para criar uma conta no GitHub: https://docs.github.com/pt/get-started/start-your-journey/creating-an-account-on-github

Para criar um repositório no GitHub: https://docs.github.com/pt/repositories/creating-and-managing-repositories/creating-a-new-repository

### Codespaces

# O que é codespaces?

Um codespace é um ambiente de desenvolvimento virtual e hospedado na nuvem, oferecido pelo GitHub. Permite que os desenvolvedores escrevam, testem e depurem código diretamente na nuvem, sem a necessidade de configurações locais complexas. 

Como criar um codespace para um repositório: https://docs.github.com/pt/codespaces/developing-in-a-codespace/creating-a-codespace-for-a-repository

### Atenção

Aprenda a função das coisas, não se preenda a gostos pessoais.

### Anotações pessoais

O Git é um controlador de versões, ele cria e gerencia várias versões do projeto. Ele faz uma cópia sempre que você o chama, não copiando totalmente, mas indicando as alterações que foram realizadas em cada versão.

O GitHub é uma rede social, no qual posso compartilhar projetos, acessar, editar, copiar e interagir com projetos de outras pessoas.

O codespaces é um espaço para eu desenvolver meus projetos, ele cria uma máquina virtual com o vscode e um terminal, no qual me permite desenvolver sem as limitações de um computador físico mais modesto.

### Referências:

https://www.atlassian.com/br/git/tutorials/what-is-git
https://docs.github.com/pt/get-startedstart-your-journey/about-github-and-git
https://docs.github.com/pt/codespaces/about-codespaces/what-are-codespaces

#################################

"Se você quiser fazer uma torta de maçã a partir do zero, você deve primeiro inventar o Universo." - Carl Sagan

Não é possível hoje começar algo do zero, vamos precisar subir no ombro de gigantes e alçar novos voos. Isso não é um problema, podemos fazer coisas incríveis em comunidade.

### Node.js

# O que é node.js

Node.js é um ambiente de execução JavaScript do lado do servidor, que permite aos desenvolvedores criar aplicações web, APIs, e outras ferramentas de linha de comando utilizando a linguagem JavaScript.

Node.js é como uma cozinha que permite preparar receitas (aplicações) usando um fogão (ambiente de execução) que entende a linguagem do JavaScript.

# Terminal 

Terminal é uma interface de linha de comando que permite interagir com um sistema operacional através de comandos digitados, sme a necissade de uma interface gráfica.

Terminal é como um pedaço de papel, ele permite que você intereja com o sistema operacional, enquanto o shell é o "motor" que interpreta e executa seus comandos.

# Shell

É uma interface que permite aos utilizadores interagir com um sistema operacional.

É como a casca de um ovo, que protege o conteúdo interno.

# NVM (Node Version Manager)

NVM é uma ferramenta que permite aos desenvolvedores gerenciar várias cersões do Node.js em um único sistema operacional.

# Para acessar os detalhes do NVM use:

nvm --help (node version manager ajuda)

### Como instalar uma versão específica do Node.js?

1º Vamos precisar listar as versões disponiveis,vamos usar o comando: 

nvm ls (node version manager list)

2º Escolha a versão, por exemplo lts/hydrogen, para isso use os comandos:

nvm install lts/hydrogen (node version manager install version)

### Como deixar a versão anterior como padrão

Para isso vamos precisar definir como padrão a versão deseja, conforme abaixo:

nvm alias default <version> (node version manager apelido padrão versão)

### Declarar a versão utilizada no projeto

Para deixar claro para outras pessoas e padronizar o projeto, precisamos deixar claro qual versão do node vai ser utilizado, fazemos isso da forma abaixo:

1º Crie o arquivo abaixo na pasta raiz do projeto.
.nvmrc (node version manager run commands)

2º Dentro escreva a versão desejada e pule uma linha.

Exemplo:
"
lts/hydrogen

"

### Next.js

É um framework React para construir aplicações web, que fornece uma estrutura e recursos extras para otimizar o desenvolvimento e melhorar o desempenho das aplicações.

É como um motor que facilita a construção de aplicações web com React.

Também para o Next e o React, é necessário indicar no projeto quais versões foram utilizadas. Para isso vamos:

1º Precisamos inicializar o node no nosso projeto e esse comando vai criar um arquivo package.json, usamos o comando:

npm init (node package manager initialize)

2º Vamos escolher a versão do next.js que será utilizado, nesse exemplo vamos usar a versão 13.1.6:

npm install next@13.1.6 (node package manager install <version>)

### React

É uma biblioteca JavaScript de software livre, popularmente utilizada para construir interfaces de usuário do lado do cliente (front-end).

É como um sistema de blocos de construção para interfaces de usuário, onde cada bloco (componente) pode ser utilizado e combinado para criar aplicações complexas.

É necessário instalar a versão do react, nesse exemplo é a 18.2.0:

npm install react@18.2.0 (node package install <version>)

O ponto é que o React foi separado entre seu core e suas renderizações, pois ele é extremamente vasto.

Para HTML, quem renderiza é o DOM, para isso vamos instalar a versão do react DOM, para manipula-lo:

npm install react-dom@18.2.0 (node package install <version>)






O que é um serviço web?

Protocolos

HTTP
FTP
SMTP
UDP
IP

UDP TCP

next dev
"dev": "next dev"


Ctrl + L

pages

index.js 

function Home() {
    return <h1>Teste</h1>
}

export default Home;

deploy



#################
Control History

Versionamento de código

sccs -> rcs -> cvs -> svn -> git
       centralizado        | distribuído

Merge

Merge conflict

Clone

ls -la

.git

Diff

Delta encoding

Blob

git log

Commit


3 estágios

1 - Modified
2 - Staged
3 - Commit

git log --stat

git status

Unstrack file

Build

.gitignore

git add nome do arquivo

git commit



git log --oneline

Working Directory

Diff

git diff

Newline

Amend

git commit --amend 

Gits são imutáveis












origin/main

branch

git push

pull

git commit -m "Mensagem"

git push --force ou --f







Continuos deployment

Client / Server


Hospedagem de site

Deploy

Continuos integration -> Build


Principle least privilege

Cada commit deployado, kkk, tem uma url unica









N1: Ser lembrado indivualmente; (Anotar tarefas no papel, em cima da mesa)
N2: Ser lembrado em grupo; (Quadro kambam)
N3: Expandir conhecimento; (Trello ou Github)
N4: Gerar metas. (Jira)


Issue inception

Milestones
    - Milestone 0: Em construção

Estágio 1 - Início
Estágio 2 - Progresso
Estágio 3 - Conclusão

Issues: 

Colocar o site num domínio .com.br
Definir estilização do código e configurar editor
Programar página de "Em construção"










Estilização de código é essencial

- [ ] - Ligar sincronização do editor
- [ ] - Configurar o EditorConfig
- [ ] - Configurar o Prettier


EditorConfig

.EditorConfig

root = true

[*] 
indent_style = space
indent_size = 2


Prettier / Standard js

npm install prettier -D ou --save-dev


no package.json
"lint:check": "prettier --check ."
"lint:fix": "prettier --write ."







DNS 2 - níveis

IP é o endereço de cada computador

DNS é um apelido

DNS <- Computador -> servidor
    ->

Recursive Resolver <- Computador
                    ->

Recursive Resolver -> Root Server
                   <-
                   -> TLD 
                   <-
                   -> Authoritative Server

FQDN

Root Domain - TLD - Authoritative Server - TTL
            ccTLD/gTLD












### Dia 12 - DNS (Prática)

Task da insue "Coloca o site num domínio .com.br"

- [ ] - Registrar domínio próprio
- [ ] - Configurar Servidor de DNS

Registrant -> Registrar -> Registry -> TLD

whatismydns -> NS

vieirarodrigo.com.br


Dizer para vercel o nosso domínio

Dizer para a TLD o nosso DNS


dig site A +trace





###  Dia 13 - 

As pessoas estão se aproximando ou se afastando?

Teoria McDonalds


99.9% Uptime
9h/Ano ou 44min/mês

SLA

Status Pages

vercel status ou aws status ou github status

RDS






### Dia 14 - Milestone 1: Fundação

## D1 - Inauguração Milestone 1: Fundação

Front-end

Milestone 1: Fundação
  Proposta de arquitetura e pastas
  Testes automatizados
  Banco de dados (Local)
  Migrations
  Continuos Integration
  Linter de código
  Linter de commits
  Banco de dados (homologação e produção)
  Tipo da licença


## D2 - Uma história macabra sobre "Overengineering"

Overengineering - Excesso de engenharia (Complexo)

Você quer estar aqui

Underengineering - (Simples e mal feito)

Um software deve ser modificável


## D3 - Porposta de Arquitetura e pastas

1. Arquitetura de software

MVC - Model View Controler

2. Organização das pastas e arquivos

root
  pages
    index.js
  models
    user.js
    content.js
    password.js
  infra
    database.js
    migration
    provisioning
      staging
      production
  tests

## D4 - Bônus: PoC e MVP ajudam mesmo?

PoC - Proof of Concept
MVP - Minimum Viable Product




### Dia 15 

## D1 - Testes Automatizados: um caminho sem volta

62 Aulas??

- [ ] - Instalar o Test Runner
- [ ] - Criar um Teste de Teste
- [ ] - Criar um Teste de Verdade

## D2 - Instalar um Test Runner

Código que executa Código

Mocha | AVA | Playwight | Jest

npm install --save-dev jest@29.6.2

"test": "jest"
"test:watch": "jest --watch"


## D3 - Criar um "Teste de Teste"

Programar uma calculadora

npm run test -watch

tests

calculadora.test.js

test("nome do teste", callbackFunction);

function callbackFunction() {
  console.log("esta função está sendo chamada?")
}

test("nome do teste", function () {
  console.log("e assim, funciona?");
})

test("nome do teste", () => {
  console.log("e agora?");
});

test("outro teste", () => {
  console.log("outro teste");
});

Expect - Espera

test("espero que 1 seja 1", () => {
  espect(1).toBe(1);
});

Valor gerado dinamicamente | Valor esperado




## D4 - Criar um "Teste de Verdade"

No MVC

Criar ferramentas (Model)

CommonJS (ESM)

Trasnpilling

expect(resultado)
Softcoded

.toBe(4)
Hardcoded

Teste não diz que o codigo está certo, mas que algo passou ou não em um teste

TDD





Resumo: 

E aí, pessoal do Curso.Dev! Sejam muito bem-vindos a mais uma aula que vai mudar completamente a forma como vocês encaram o desenvolvimento de software. Eu sei que o Felipe já tocou na importância disso, mas hoje, a gente vai mergulhar de cabeça nos **Testes Automatizados: um caminho sem volta**! Preparem-se para uma sacada que vai acelerar a carreira de vocês.

Pensem comigo: no desenvolvimento de software moderno, testar manualmente cada alteração de código é como tentar esvaziar o Oceano Atlântico com um balde. Inviável e ineficiente, né? É por isso que os testes automatizados são um pilar fundamental, proporcionando confiança, segurança e agilidade para o projeto. Eles garantem que, a cada nova funcionalidade ou correção, o comportamento esperado da aplicação seja verificado de forma automática.

Vamos estruturar nossa aula em três etapas essenciais, seguindo a didática que a gente tanto preza:

### 1. Instalar um Test Runner

Primeiro, a gente precisa de uma ferramenta para "rodar" nossos testes. Pensem no "Test Runner" como o maestro da orquestra dos seus testes. Ele é um código que procura os arquivos de teste no seu projeto, executa o que você escreveu e te apresenta um relatório claro do que passou e do que falhou. No ecossistema JavaScript, temos várias opções de peso no mercado, como Mocha, AVA, Playwright e, claro, o **Jest**.

O Jest, desenvolvido pelo Facebook e recomendado pela equipe do React, é um dos frameworks de teste mais populares e poderosos para projetos JavaScript. Por que ele? Simplicidade de configuração, execução rápida, mock integrado, suporte a ES6/TypeScript e uma comunidade ativa que é um verdadeiro *dream team* para tirar dúvidas.

**Como a gente instala o Jest?** Moleza! Primeiro, se você ainda não tem um projeto Node.js inicializado, comece com:

```bash
npm init -y
```
Depois, adicione o Jest como uma dependência de desenvolvimento (ou seja, ele só é necessário para quem vai desenvolver e testar, não para a versão final da aplicação):

```bash
npm install --save-dev jest
```
Isso instala a ferramenta que vai fazer a mágica acontecer.

Agora, uma **sacada de produtividade**: vamos configurar os scripts no seu `package.json` para facilitar a vida. Abra o seu `package.json` e adicione (ou ajuste) a seção `scripts` assim:

```json
// package.json
{
  ...
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch"
  },
  ...
}
```
Com `"test": "jest"`, você roda todos os testes do projeto uma vez com `npm test`. Já o `"test:watch": "jest --watch"` é um verdadeiro *game-changer* durante o desenvolvimento! Ele faz com que o Jest fique "escutando" as alterações nos seus arquivos e, ao salvar, roda automaticamente apenas os testes relevantes, dando um feedback instantâneo. Isso é agilidade pura!

### 2. Criar um "Teste de Teste" (Sanity Check)

Antes de testar a lógica complexa da sua aplicação, a gente sempre começa com um "Teste de Teste" ou um *sanity check*. O objetivo aqui é super simples: validar se o Jest foi configurado corretamente e se ele está conseguindo encontrar e executar os arquivos de teste. É a prova de vida do seu ambiente de testes!

Para isso, o Jest automaticamente reconhece arquivos com a extensão `.test.js` (ou `.spec.js`) como arquivos de teste. Uma estrutura comum para o seu projeto seria ter uma pasta `src` para o seu código e uma pasta `tests` para os seus testes.

Vamos criar um arquivo dentro da sua pasta `tests`, por exemplo, `meuprimeiro.test.js`:

```javascript
// meuprimeiro.test.js
test("espero que 1 seja 1", () => {
  // expect(valor_gerado).toBe(valor_esperado);
  expect(1).toBe(1);
});
```

A função `test()` define um teste individual, recebendo uma descrição em string e uma função *callback* com a lógica do teste. E o coração do teste? É a função `expect()` combinada com um "matcher" como o `.toBe()`. O `expect(valor_dinamico).toBe(valor_esperado)` é a forma de afirmar que o resultado do seu código (`valor_dinamico`) é exatamente igual ao que você esperava (`valor_esperado`).

Agora, execute seu "Teste de Teste" no terminal:

```bash
npm test
```

Se tudo deu certo, você verá uma saída parecida com esta:

```
PASS tests/meuprimeiro.test.js
✓ espero que 1 seja 1 (x ms)
```
Isso confirma que seu ambiente de testes está funcionando perfeitamente! Palmas para vocês!

### 3. Criar um "Teste de Verdade"

Com o ambiente validado, é hora de testar uma funcionalidade real da sua aplicação. Vamos pegar um exemplo clássico, como testar uma função `soma` em um arquivo `funcoes.js`.

Se você estiver seguindo padrões como MVC (Model-View-Controller), essa função estaria na sua camada de Model, onde ficam as regras de negócio.

Primeiro, crie o arquivo `src/funcoes.js` com a sua função:

```javascript
// src/funcoes.js
function soma(a, b) {
  return a + b;
}

module.exports = { soma }; // Usando CommonJS para exportar
```
**Atenção aqui!** Para o arquivo de teste poder acessar sua função `soma`, você precisa exportá-la. Usamos `module.exports` e `require` para módulos CommonJS, que é o padrão mais comum em projetos Node.js mais antigos e é o que o Jest usa por padrão. Se você estivesse em um projeto mais moderno com ES Modules (ESM), usaria `export` e `import`, mas isso pode exigir alguma configuração adicional, como um *transpiler* tipo Babel, para garantir compatibilidade com ambientes que ainda não suportam ESM nativamente. No nosso caso simples, `module.exports` e `require` funcionam direto com Jest.

Agora, crie o arquivo de teste `tests/funcoes.test.js`:

```javascript
// tests/funcoes.test.js
const { soma } = require('../src/funcoes'); // Importando a função a ser testada

test('soma dois números', () => {
  expect(soma(1, 2)).toBe(3);
});

test('soma números negativos', () => {
  expect(soma(-1, -2)).toBe(-3);
});

test('soma com zero', () => {
  expect(soma(5, 0)).toBe(5);
});
```

Execute novamente `npm test` e veja a mágica acontecer! Você verá todos os seus testes passando.

Uma "sacada" importantíssima sobre testes é a diferença entre valores "hardcoded" e "softcoded".
*   **Hardcoded (Valor Fixo):** É o valor que você escreve diretamente no teste como o resultado esperado. No exemplo `expect(resultado).toBe(4);`, o `4` é *hardcoded*. Isso é fundamental em testes unitários, pois você quer garantir que uma entrada específica sempre gere uma saída específica e previsível.
*   **Softcoded (Valor Dinâmico):** Refere-se ao valor gerado pelo seu código, como a variável `resultado` em `expect(resultado)`. Esse valor é dinâmico e será comparado com o valor *hardcoded* que você espera.

**Filosofia do Teste:** Entendam bem isso: um teste que passa *não prova* que seu código está 100% certo. Ele apenas prova que, para a *situação específica* que você testou, o código se comportou como o esperado. Se a sua função `soma` fosse `return 4;`, o teste `soma(1,2).toBe(3)` falharia, mas `soma(2,2).toBe(4)` passaria – o que mostra a necessidade de múltiplos casos de teste para ter confiança.

Isso nos leva a uma metodologia poderosa: o **TDD - Test-Driven Development (Desenvolvimento Guiado por Testes)**. O ciclo é simples, mas revolucionário:
1.  **Red (Vermelho):** Escreva um teste para uma funcionalidade que ainda não existe. Rode o teste e veja-o falhar.
2.  **Green (Verde):** Escreva o *mínimo* de código possível para fazer o teste passar.
3.  **Refactor (Refatorar):** Melhore o código que você escreveu sem alterar seu comportamento, garantindo que o teste continue passando.

Essa abordagem não só garante que seu código esteja coberto por testes desde o início, mas também incentiva a criação de um código mais simples, modular e fácil de manter!

Para ir além, vocês podem até gerar relatórios de **cobertura de código** com Jest. Basta adicionar `--coverage` ao script de teste no `package.json`:

```json
// package.json
{
  ...
  "scripts": {
    "test": "jest --coverage"
  },
  ...
}
```
Ao rodar `npm test` novamente, o Jest vai gerar um relatório detalhado mostrando a porcentagem do seu código que está sendo coberta pelos testes. Isso é crucial para entender quão "testado" seu código realmente está.

É isso, pessoal! Vocês deram os primeiros passos sólidos em testes automatizados com Jest. Lembrem-se: testes não são um custo, são um **investimento** na qualidade e na sustentabilidade do seu software. Continuem explorando e testando sem medo! E qualquer dúvida, podem me procurar, porque aqui no Curso.Dev, a gente não deixa ninguém para trás. Bons códigos!