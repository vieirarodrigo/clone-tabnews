### Git e GitHub

# O que é Git?

O Git é um sistema de controle de versão distribuído, gratuito e de código aberto, que permite rastrear e gerenciar as alterações em um projeto de software ao longo do tempo. Ele foi criado por Linus Torvalds em 2005. O Git é uma ferramenta essencial para desenvolvedores, facilitando a colaboração em projetos, a criação de versões e a reversão de alterações caso necessário. 

O Git é como se fosse um vídeo no meu computador.

# O que é GitHub?

O GitHub é uma plataforma online que funciona como um grande repositório de código de programação, onde desenvolvedores podem armazenar, compartilhar e colaborar em projetos. É essencialmente uma rede social para programadores, facilitando o trabalho em equipe e a colaboração em projetos de código aberto. 

O GitHub é como o YouTube, uma plataforma que posso compartilhar ou assistir outros videos.

Para criar uma conta no GitHub: https://docs.github.com/pt/get-started/start-your-journey/creating-an-account-on-github

Para criar um repositório no GitHub: https://docs.github.com/pt/repositories/creating-and-managing-repositories/creating-a-new-repository

### Codespaces

# O que é codespaces?

Um codespace é um ambiente de desenvolvimento virtual e hospedado na nuvem, oferecido pelo GitHub. Permite que os desenvolvedores escrevam, testem e depurem código diretamente na nuvem, sem a necessidade de configurações locais complexas. 

Como criar um codespace para um repositório: https://docs.github.com/pt/codespaces/developing-in-a-codespace/creating-a-codespace-for-a-repository

### Atenção

Aprenda a função das coisas, não se preenda a gostos pessoais.

### Anotações pessoais

O Git é um controlador de versões, ele cria e gerencia várias versões do projeto. Ele faz uma cópia sempre que você o chama, não copiando totalmente, mas indicando as alterações que foram realizadas em cada versão.

O GitHub é uma rede social, no qual posso compartilhar projetos, acessar, editar, copiar e interagir com projetos de outras pessoas.

O codespaces é um espaço para eu desenvolver meus projetos, ele cria uma máquina virtual com o vscode e um terminal, no qual me permite desenvolver sem as limitações de um computador físico mais modesto.

### Referências:

https://www.atlassian.com/br/git/tutorials/what-is-git
https://docs.github.com/pt/get-startedstart-your-journey/about-github-and-git
https://docs.github.com/pt/codespaces/about-codespaces/what-are-codespaces

#################################

"Se você quiser fazer uma torta de maçã a partir do zero, você deve primeiro inventar o Universo." - Carl Sagan

Não é possível hoje começar algo do zero, vamos precisar subir no ombro de gigantes e alçar novos voos. Isso não é um problema, podemos fazer coisas incríveis em comunidade.

### Node.js

# O que é node.js

Node.js é um ambiente de execução JavaScript do lado do servidor, que permite aos desenvolvedores criar aplicações web, APIs, e outras ferramentas de linha de comando utilizando a linguagem JavaScript.

Node.js é como uma cozinha que permite preparar receitas (aplicações) usando um fogão (ambiente de execução) que entende a linguagem do JavaScript.

# Terminal 

Terminal é uma interface de linha de comando que permite interagir com um sistema operacional através de comandos digitados, sme a necissade de uma interface gráfica.

Terminal é como um pedaço de papel, ele permite que você intereja com o sistema operacional, enquanto o shell é o "motor" que interpreta e executa seus comandos.

# Shell

É uma interface que permite aos utilizadores interagir com um sistema operacional.

É como a casca de um ovo, que protege o conteúdo interno.

# NVM (Node Version Manager)

NVM é uma ferramenta que permite aos desenvolvedores gerenciar várias cersões do Node.js em um único sistema operacional.

# Para acessar os detalhes do NVM use:

nvm --help (node version manager ajuda)

### Como instalar uma versão específica do Node.js?

1º Vamos precisar listar as versões disponiveis,vamos usar o comando: 

nvm ls (node version manager list)

2º Escolha a versão, por exemplo lts/hydrogen, para isso use os comandos:

nvm install lts/hydrogen (node version manager install version)

### Como deixar a versão anterior como padrão

Para isso vamos precisar definir como padrão a versão deseja, conforme abaixo:

nvm alias default <version> (node version manager apelido padrão versão)

### Declarar a versão utilizada no projeto

Para deixar claro para outras pessoas e padronizar o projeto, precisamos deixar claro qual versão do node vai ser utilizado, fazemos isso da forma abaixo:

1º Crie o arquivo abaixo na pasta raiz do projeto.
.nvmrc (node version manager run commands)

2º Dentro escreva a versão desejada e pule uma linha.

Exemplo:
"
lts/hydrogen

"

### Next.js

É um framework React para construir aplicações web, que fornece uma estrutura e recursos extras para otimizar o desenvolvimento e melhorar o desempenho das aplicações.

É como um motor que facilita a construção de aplicações web com React.

Também para o Next e o React, é necessário indicar no projeto quais versões foram utilizadas. Para isso vamos:

1º Precisamos inicializar o node no nosso projeto e esse comando vai criar um arquivo package.json, usamos o comando:

npm init (node package manager initialize)

2º Vamos escolher a versão do next.js que será utilizado, nesse exemplo vamos usar a versão 13.1.6:

npm install next@13.1.6 (node package manager install <version>)

### React

É uma biblioteca JavaScript de software livre, popularmente utilizada para construir interfaces de usuário do lado do cliente (front-end).

É como um sistema de blocos de construção para interfaces de usuário, onde cada bloco (componente) pode ser utilizado e combinado para criar aplicações complexas.

É necessário instalar a versão do react, nesse exemplo é a 18.2.0:

npm install react@18.2.0 (node package install <version>)

O ponto é que o React foi separado entre seu core e suas renderizações, pois ele é extremamente vasto.

Para HTML, quem renderiza é o DOM, para isso vamos instalar a versão do react DOM, para manipula-lo:

npm install react-dom@18.2.0 (node package install <version>)






O que é um serviço web?

Protocolos

HTTP
FTP
SMTP
UDP
IP

UDP TCP

next dev
"dev": "next dev"


Ctrl + L

pages

index.js 

function Home() {
    return <h1>Teste</h1>
}

export default Home;

deploy



#################
Control History

Versionamento de código

sccs -> rcs -> cvs -> svn -> git
       centralizado        | distribuído

Merge

Merge conflict

Clone

ls -la

.git

Diff

Delta encoding

Blob

git log

Commit


3 estágios

1 - Modified
2 - Staged
3 - Commit

git log --stat

git status

Unstrack file

Build

.gitignore

git add nome do arquivo

git commit



git log --oneline

Working Directory

Diff

git diff

Newline

Amend

git commit --amend 

Gits são imutáveis












origin/main

branch

git push

pull

git commit -m "Mensagem"

git push --force ou --f







Continuos deployment

Client / Server


Hospedagem de site

Deploy

Continuos integration -> Build


Principle least privilege

Cada commit deployado, kkk, tem uma url unica









N1: Ser lembrado indivualmente; (Anotar tarefas no papel, em cima da mesa)
N2: Ser lembrado em grupo; (Quadro kambam)
N3: Expandir conhecimento; (Trello ou Github)
N4: Gerar metas. (Jira)


Issue inception

Milestones
    - Milestone 0: Em construção

Estágio 1 - Início
Estágio 2 - Progresso
Estágio 3 - Conclusão

Issues: 

Colocar o site num domínio .com.br
Definir estilização do código e configurar editor
Programar página de "Em construção"










Estilização de código é essencial

- [ ] - Ligar sincronização do editor
- [ ] - Configurar o EditorConfig
- [ ] - Configurar o Prettier


EditorConfig

.EditorConfig

root = true

[*] 
indent_style = space
indent_size = 2


Prettier / Standard js

npm install prettier -D ou --save-dev


no package.json
"lint:check": "prettier --check ."
"lint:fix": "prettier --write ."







DNS 2 - níveis

IP é o endereço de cada computador

DNS é um apelido

DNS <- Computador -> servidor
    ->

Recursive Resolver <- Computador
                    ->

Recursive Resolver -> Root Server
                   <-
                   -> TLD 
                   <-
                   -> Authoritative Server

FQDN

Root Domain - TLD - Authoritative Server - TTL
            ccTLD/gTLD












### Dia 12 - DNS (Prática)

Task da insue "Coloca o site num domínio .com.br"

- [ ] - Registrar domínio próprio
- [ ] - Configurar Servidor de DNS

Registrant -> Registrar -> Registry -> TLD

whatismydns -> NS

vieirarodrigo.com.br


Dizer para vercel o nosso domínio

Dizer para a TLD o nosso DNS


### Git e GitHub

# O que é Git?

O Git é um sistema de controle de versão distribuído, gratuito e de código aberto, que permite rastrear e gerenciar as alterações em um projeto de software ao longo do tempo. Ele foi criado por Linus Torvalds em 2005. O Git é uma ferramenta essencial para desenvolvedores, facilitando a colaboração em projetos, a criação de versões e a reversão de alterações caso necessário. 

O Git é como se fosse um vídeo no meu computador.

# O que é GitHub?

O GitHub é uma plataforma online que funciona como um grande repositório de código de programação, onde desenvolvedores podem armazenar, compartilhar e colaborar em projetos. É essencialmente uma rede social para programadores, facilitando o trabalho em equipe e a colaboração em projetos de código aberto. 

O GitHub é como o YouTube, uma plataforma que posso compartilhar ou assistir outros videos.

Para criar uma conta no GitHub: https://docs.github.com/pt/get-started/start-your-journey/creating-an-account-on-github

Para criar um repositório no GitHub: https://docs.github.com/pt/repositories/creating-and-managing-repositories/creating-a-new-repository

### Codespaces

# O que é codespaces?

Um codespace é um ambiente de desenvolvimento virtual e hospedado na nuvem, oferecido pelo GitHub. Permite que os desenvolvedores escrevam, testem e depurem código diretamente na nuvem, sem a necessidade de configurações locais complexas. 

Como criar um codespace para um repositório: https://docs.github.com/pt/codespaces/developing-in-a-codespace/creating-a-codespace-for-a-repository

### Atenção

Aprenda a função das coisas, não se preenda a gostos pessoais.

### Anotações pessoais

O Git é um controlador de versões, ele cria e gerencia várias versões do projeto. Ele faz uma cópia sempre que você o chama, não copiando totalmente, mas indicando as alterações que foram realizadas em cada versão.

O GitHub é uma rede social, no qual posso compartilhar projetos, acessar, editar, copiar e interagir com projetos de outras pessoas.

O codespaces é um espaço para eu desenvolver meus projetos, ele cria uma máquina virtual com o vscode e um terminal, no qual me permite desenvolver sem as limitações de um computador físico mais modesto.

### Referências:

https://www.atlassian.com/br/git/tutorials/what-is-git
https://docs.github.com/pt/get-startedstart-your-journey/about-github-and-git
https://docs.github.com/pt/codespaces/about-codespaces/what-are-codespaces

#################################

"Se você quiser fazer uma torta de maçã a partir do zero, você deve primeiro inventar o Universo." - Carl Sagan

Não é possível hoje começar algo do zero, vamos precisar subir no ombro de gigantes e alçar novos voos. Isso não é um problema, podemos fazer coisas incríveis em comunidade.

### Node.js

# O que é node.js

Node.js é um ambiente de execução JavaScript do lado do servidor, que permite aos desenvolvedores criar aplicações web, APIs, e outras ferramentas de linha de comando utilizando a linguagem JavaScript.

Node.js é como uma cozinha que permite preparar receitas (aplicações) usando um fogão (ambiente de execução) que entende a linguagem do JavaScript.

# Terminal 

Terminal é uma interface de linha de comando que permite interagir com um sistema operacional através de comandos digitados, sme a necissade de uma interface gráfica.

Terminal é como um pedaço de papel, ele permite que você intereja com o sistema operacional, enquanto o shell é o "motor" que interpreta e executa seus comandos.

# Shell

É uma interface que permite aos utilizadores interagir com um sistema operacional.

É como a casca de um ovo, que protege o conteúdo interno.

# NVM (Node Version Manager)

NVM é uma ferramenta que permite aos desenvolvedores gerenciar várias cersões do Node.js em um único sistema operacional.

# Para acessar os detalhes do NVM use:

nvm --help (node version manager ajuda)

### Como instalar uma versão específica do Node.js?

1º Vamos precisar listar as versões disponiveis,vamos usar o comando: 

nvm ls (node version manager list)

2º Escolha a versão, por exemplo lts/hydrogen, para isso use os comandos:

nvm install lts/hydrogen (node version manager install version)

### Como deixar a versão anterior como padrão

Para isso vamos precisar definir como padrão a versão deseja, conforme abaixo:

nvm alias default <version> (node version manager apelido padrão versão)

### Declarar a versão utilizada no projeto

Para deixar claro para outras pessoas e padronizar o projeto, precisamos deixar claro qual versão do node vai ser utilizado, fazemos isso da forma abaixo:

1º Crie o arquivo abaixo na pasta raiz do projeto.
.nvmrc (node version manager run commands)

2º Dentro escreva a versão desejada e pule uma linha.

Exemplo:
"
lts/hydrogen

"

### Next.js

É um framework React para construir aplicações web, que fornece uma estrutura e recursos extras para otimizar o desenvolvimento e melhorar o desempenho das aplicações.

É como um motor que facilita a construção de aplicações web com React.

Também para o Next e o React, é necessário indicar no projeto quais versões foram utilizadas. Para isso vamos:

1º Precisamos inicializar o node no nosso projeto e esse comando vai criar um arquivo package.json, usamos o comando:

npm init (node package manager initialize)

2º Vamos escolher a versão do next.js que será utilizado, nesse exemplo vamos usar a versão 13.1.6:

npm install next@13.1.6 (node package manager install <version>)

### React

É uma biblioteca JavaScript de software livre, popularmente utilizada para construir interfaces de usuário do lado do cliente (front-end).

É como um sistema de blocos de construção para interfaces de usuário, onde cada bloco (componente) pode ser utilizado e combinado para criar aplicações complexas.

É necessário instalar a versão do react, nesse exemplo é a 18.2.0:

npm install react@18.2.0 (node package install <version>)

O ponto é que o React foi separado entre seu core e suas renderizações, pois ele é extremamente vasto.

Para HTML, quem renderiza é o DOM, para isso vamos instalar a versão do react DOM, para manipula-lo:

npm install react-dom@18.2.0 (node package install <version>)






O que é um serviço web?

Protocolos

HTTP
FTP
SMTP
UDP
IP

UDP TCP

next dev
"dev": "next dev"


Ctrl + L

pages

index.js 

function Home() {
    return <h1>Teste</h1>
}

export default Home;

deploy



#################
Control History

Versionamento de código

sccs -> rcs -> cvs -> svn -> git
       centralizado        | distribuído

Merge

Merge conflict

Clone

ls -la

.git

Diff

Delta encoding

Blob

git log

Commit


3 estágios

1 - Modified
2 - Staged
3 - Commit

git log --stat

git status

Unstrack file

Build

.gitignore

git add nome do arquivo

git commit



git log --oneline

Working Directory

Diff

git diff

Newline

Amend

git commit --amend 

Gits são imutáveis












origin/main

branch

git push

pull

git commit -m "Mensagem"

git push --force ou --f







Continuos deployment

Client / Server


Hospedagem de site

Deploy

Continuos integration -> Build


Principle least privilege

Cada commit deployado, kkk, tem uma url unica









N1: Ser lembrado indivualmente; (Anotar tarefas no papel, em cima da mesa)
N2: Ser lembrado em grupo; (Quadro kambam)
N3: Expandir conhecimento; (Trello ou Github)
N4: Gerar metas. (Jira)


Issue inception

Milestones
    - Milestone 0: Em construção

Estágio 1 - Início
Estágio 2 - Progresso
Estágio 3 - Conclusão

Issues: 

Colocar o site num domínio .com.br
Definir estilização do código e configurar editor
Programar página de "Em construção"










Estilização de código é essencial

- [ ] - Ligar sincronização do editor
- [ ] - Configurar o EditorConfig
- [ ] - Configurar o Prettier


EditorConfig

.EditorConfig

root = true

[*] 
indent_style = space
indent_size = 2


Prettier / Standard js

npm install prettier -D ou --save-dev


no package.json
"lint:check": "prettier --check ."
"lint:fix": "prettier --write ."







DNS 2 - níveis

IP é o endereço de cada computador

DNS é um apelido

DNS <- Computador -> servidor
    ->

Recursive Resolver <- Computador
                    ->

Recursive Resolver -> Root Server
                   <-
                   -> TLD 
                   <-
                   -> Authoritative Server

FQDN

Root Domain - TLD - Authoritative Server - TTL
            ccTLD/gTLD












### Dia 12 - DNS (Prática)

Task da insue "Coloca o site num domínio .com.br"

- [ ] - Registrar domínio próprio
- [ ] - Configurar Servidor de DNS

Registrant -> Registrar -> Registry -> TLD

whatismydns -> NS

vieirarodrigo.com.br


Dizer para vercel o nosso domínio

Dizer para a TLD o nosso DNS


dig site A +trace





###  Dia 13 - 

As pessoas estão se aproximando ou se afastando?

Teoria McDonalds


99.9% Uptime
9h/Ano ou 44min/mês

SLA

Status Pages

vercel status ou aws status ou github status

RDS






### Dia 14 - Milestone 1: Fundação

## D1 - Inauguração Milestone 1: Fundação

Front-end

Milestone 1: Fundação
  Proposta de arquitetura e pastas
  Testes automatizados
  Banco de dados (Local)
  Migrations
  Continuos Integration
  Linter de código
  Linter de commits
  Banco de dados (homologação e produção)
  Tipo da licença


## D2 - Uma história macabra sobre "Overengineering"

Overengineering - Excesso de engenharia (Complexo)

Você quer estar aqui

Underengineering - (Simples e mal feito)

Um software deve ser modificável


## D3 - Porposta de Arquitetura e pastas

1. Arquitetura de software

MVC - Model View Controler

2. Organização das pastas e arquivos

root
  pages
    index.js
  models
    user.js
    content.js
    password.js
  infra
    database.js
    migration
    provisioning
      staging
      production
  tests

## D4 - Bônus: PoC e MVP ajudam mesmo?

PoC - Proof of Concept
MVP - Minimum Viable Product




### Dia 15 

## D1 - Testes Automatizados: um caminho sem volta

62 Aulas??

- [ ] - Instalar o Test Runner
- [ ] - Criar um Teste de Teste
- [ ] - Criar um Teste de Verdade

## D2 - Instalar um Test Runner

Código que executa Código

Mocha | AVA | Playwight | Jest

npm install --save-dev jest@29.6.2

"test": "jest"
"test:watch": "jest --watch"


## D3 - Criar um "Teste de Teste"

Programar uma calculadora

npm run test -watch

tests

calculadora.test.js

test("nome do teste", callbackFunction);

function callbackFunction() {
  console.log("esta função está sendo chamada?")
}

test("nome do teste", function () {
  console.log("e assim, funciona?");
})

test("nome do teste", () => {
  console.log("e agora?");
});

test("outro teste", () => {
  console.log("outro teste");
});

Expect - Espera

test("espero que 1 seja 1", () => {
  espect(1).toBe(1);
});

Valor gerado dinamicamente | Valor esperado




## D4 - Criar um "Teste de Verdade"

No MVC

Criar ferramentas (Model)

CommonJS (ESM)

Trasnpilling

expect(resultado)
Softcoded

.toBe(4)
Hardcoded

Teste não diz que o codigo está certo, mas que algo passou ou não em um teste

TDD





Resumo: 

E aí, pessoal do Curso.Dev! Sejam muito bem-vindos a mais uma aula que vai mudar completamente a forma como vocês encaram o desenvolvimento de software. Eu sei que o Felipe já tocou na importância disso, mas hoje, a gente vai mergulhar de cabeça nos **Testes Automatizados: um caminho sem volta**! Preparem-se para uma sacada que vai acelerar a carreira de vocês.

Pensem comigo: no desenvolvimento de software moderno, testar manualmente cada alteração de código é como tentar esvaziar o Oceano Atlântico com um balde. Inviável e ineficiente, né? É por isso que os testes automatizados são um pilar fundamental, proporcionando confiança, segurança e agilidade para o projeto. Eles garantem que, a cada nova funcionalidade ou correção, o comportamento esperado da aplicação seja verificado de forma automática.

Vamos estruturar nossa aula em três etapas essenciais, seguindo a didática que a gente tanto preza:

### 1. Instalar um Test Runner

Primeiro, a gente precisa de uma ferramenta para "rodar" nossos testes. Pensem no "Test Runner" como o maestro da orquestra dos seus testes. Ele é um código que procura os arquivos de teste no seu projeto, executa o que você escreveu e te apresenta um relatório claro do que passou e do que falhou. No ecossistema JavaScript, temos várias opções de peso no mercado, como Mocha, AVA, Playwright e, claro, o **Jest**.

O Jest, desenvolvido pelo Facebook e recomendado pela equipe do React, é um dos frameworks de teste mais populares e poderosos para projetos JavaScript. Por que ele? Simplicidade de configuração, execução rápida, mock integrado, suporte a ES6/TypeScript e uma comunidade ativa que é um verdadeiro *dream team* para tirar dúvidas.

**Como a gente instala o Jest?** Moleza! Primeiro, se você ainda não tem um projeto Node.js inicializado, comece com:

```bash
npm init -y
```
Depois, adicione o Jest como uma dependência de desenvolvimento (ou seja, ele só é necessário para quem vai desenvolver e testar, não para a versão final da aplicação):

```bash
npm install --save-dev jest
```
Isso instala a ferramenta que vai fazer a mágica acontecer.

Agora, uma **sacada de produtividade**: vamos configurar os scripts no seu `package.json` para facilitar a vida. Abra o seu `package.json` e adicione (ou ajuste) a seção `scripts` assim:

```json
// package.json
{
  ...
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch"
  },
  ...
}
```
Com `"test": "jest"`, você roda todos os testes do projeto uma vez com `npm test`. Já o `"test:watch": "jest --watch"` é um verdadeiro *game-changer* durante o desenvolvimento! Ele faz com que o Jest fique "escutando" as alterações nos seus arquivos e, ao salvar, roda automaticamente apenas os testes relevantes, dando um feedback instantâneo. Isso é agilidade pura!

### 2. Criar um "Teste de Teste" (Sanity Check)

Antes de testar a lógica complexa da sua aplicação, a gente sempre começa com um "Teste de Teste" ou um *sanity check*. O objetivo aqui é super simples: validar se o Jest foi configurado corretamente e se ele está conseguindo encontrar e executar os arquivos de teste. É a prova de vida do seu ambiente de testes!

Para isso, o Jest automaticamente reconhece arquivos com a extensão `.test.js` (ou `.spec.js`) como arquivos de teste. Uma estrutura comum para o seu projeto seria ter uma pasta `src` para o seu código e uma pasta `tests` para os seus testes.

Vamos criar um arquivo dentro da sua pasta `tests`, por exemplo, `meuprimeiro.test.js`:

```javascript
// meuprimeiro.test.js
test("espero que 1 seja 1", () => {
  // expect(valor_gerado).toBe(valor_esperado);
  expect(1).toBe(1);
});
```

A função `test()` define um teste individual, recebendo uma descrição em string e uma função *callback* com a lógica do teste. E o coração do teste? É a função `expect()` combinada com um "matcher" como o `.toBe()`. O `expect(valor_dinamico).toBe(valor_esperado)` é a forma de afirmar que o resultado do seu código (`valor_dinamico`) é exatamente igual ao que você esperava (`valor_esperado`).

Agora, execute seu "Teste de Teste" no terminal:

```bash
npm test
```

Se tudo deu certo, você verá uma saída parecida com esta:

```
PASS tests/meuprimeiro.test.js
✓ espero que 1 seja 1 (x ms)
```
Isso confirma que seu ambiente de testes está funcionando perfeitamente! Palmas para vocês!

### 3. Criar um "Teste de Verdade"

Com o ambiente validado, é hora de testar uma funcionalidade real da sua aplicação. Vamos pegar um exemplo clássico, como testar uma função `soma` em um arquivo `funcoes.js`.

Se você estiver seguindo padrões como MVC (Model-View-Controller), essa função estaria na sua camada de Model, onde ficam as regras de negócio.

Primeiro, crie o arquivo `src/funcoes.js` com a sua função:

```javascript
// src/funcoes.js
function soma(a, b) {
  return a + b;
}

module.exports = { soma }; // Usando CommonJS para exportar
```
**Atenção aqui!** Para o arquivo de teste poder acessar sua função `soma`, você precisa exportá-la. Usamos `module.exports` e `require` para módulos CommonJS, que é o padrão mais comum em projetos Node.js mais antigos e é o que o Jest usa por padrão. Se você estivesse em um projeto mais moderno com ES Modules (ESM), usaria `export` e `import`, mas isso pode exigir alguma configuração adicional, como um *transpiler* tipo Babel, para garantir compatibilidade com ambientes que ainda não suportam ESM nativamente. No nosso caso simples, `module.exports` e `require` funcionam direto com Jest.

Agora, crie o arquivo de teste `tests/funcoes.test.js`:

```javascript
// tests/funcoes.test.js
const { soma } = require('../src/funcoes'); // Importando a função a ser testada

test('soma dois números', () => {
  expect(soma(1, 2)).toBe(3);
});

test('soma números negativos', () => {
  expect(soma(-1, -2)).toBe(-3);
});

test('soma com zero', () => {
  expect(soma(5, 0)).toBe(5);
});
```

Execute novamente `npm test` e veja a mágica acontecer! Você verá todos os seus testes passando.

Uma "sacada" importantíssima sobre testes é a diferença entre valores "hardcoded" e "softcoded".
*   **Hardcoded (Valor Fixo):** É o valor que você escreve diretamente no teste como o resultado esperado. No exemplo `expect(resultado).toBe(4);`, o `4` é *hardcoded*. Isso é fundamental em testes unitários, pois você quer garantir que uma entrada específica sempre gere uma saída específica e previsível.
*   **Softcoded (Valor Dinâmico):** Refere-se ao valor gerado pelo seu código, como a variável `resultado` em `expect(resultado)`. Esse valor é dinâmico e será comparado com o valor *hardcoded* que você espera.

**Filosofia do Teste:** Entendam bem isso: um teste que passa *não prova* que seu código está 100% certo. Ele apenas prova que, para a *situação específica* que você testou, o código se comportou como o esperado. Se a sua função `soma` fosse `return 4;`, o teste `soma(1,2).toBe(3)` falharia, mas `soma(2,2).toBe(4)` passaria – o que mostra a necessidade de múltiplos casos de teste para ter confiança.

Isso nos leva a uma metodologia poderosa: o **TDD - Test-Driven Development (Desenvolvimento Guiado por Testes)**. O ciclo é simples, mas revolucionário:
1.  **Red (Vermelho):** Escreva um teste para uma funcionalidade que ainda não existe. Rode o teste e veja-o falhar.
2.  **Green (Verde):** Escreva o *mínimo* de código possível para fazer o teste passar.
3.  **Refactor (Refatorar):** Melhore o código que você escreveu sem alterar seu comportamento, garantindo que o teste continue passando.

Essa abordagem não só garante que seu código esteja coberto por testes desde o início, mas também incentiva a criação de um código mais simples, modular e fácil de manter!

Para ir além, vocês podem até gerar relatórios de **cobertura de código** com Jest. Basta adicionar `--coverage` ao script de teste no `package.json`:

```json
// package.json
{
  ...
  "scripts": {
    "test": "jest --coverage"
  },
  ...
}
```
Ao rodar `npm test` novamente, o Jest vai gerar um relatório detalhado mostrando a porcentagem do seu código que está sendo coberta pelos testes. Isso é crucial para entender quão "testado" seu código realmente está.

É isso, pessoal! Vocês deram os primeiros passos sólidos em testes automatizados com Jest. Lembrem-se: testes não são um custo, são um **investimento** na qualidade e na sustentabilidade do seu software. Continuem explorando e testando sem medo! E qualquer dúvida, podem me procurar, porque aqui no Curso.Dev, a gente não deixa ninguém para trás. Bons códigos!


Dia 16: 

🚗 Pista Rápida: Dia 16

O Dia 16 é mais um daqueles dias especiais aqui no curso.dev porque mistura parte teórica, parte prática e também como ser um profissional melhor. E eu diria que esta última parte de ser um profissional melhor é o que faz grudar na sua mente a parte teórica e prática, tanto que no final dessa Pista Rápida aqui eu adicionei uma mensagem extra que eu não coloquei em nenhuma Pista Lenta 💪

Anotações:

Este dia focou em como garantir a qualidade e a comunicação em software, culminando em uma lição fundamental sobre como abordar a tecnologia.

1. Estratégia de Testes: Garantindo a Qualidade
A qualidade do software é verificada através de diferentes tipos de testes, organizados estrategicamente.

Pirâmide de Testes: É o modelo clássico para pensar em testes.
  * Base (Testes Unitários): Testam a menor parte do código (uma função, um componente) de forma isolada. São rápidos, baratos e devem existir em grande quantidade.
  
  * Meio (Testes de Integração): Verificam se diferentes unidades do sistema funcionam corretamente juntas. Exemplo: testar se a API, ao ser chamada, consegue de fato gravar os dados no banco de dados. São mais lentos e complexos que os testes unitários.
  
  * Topo (Testes de Ponta-a-Ponta): Simulam a jornada completa do usuário na aplicação. São os mais lentos e caros.

Alternativas: Existem outros modelos além da pirâmide (como o "favo de mel"), mas o princípio de ter uma estratégia com diferentes camadas de teste permanece.

2. APIs: A Linguagem da Comunicação entre Sistemas
Os testes de integração frequentemente validam a comunicação entre diferentes partes de um sistema, que ocorre via APIs.

API (Interface de Programação de Aplicações): É um contrato que define como um software "conversa" com outro. O conceito de "interface" é universal: pode ser uma interface gráfica (para um humano) ou uma interface programática (para outro sistema).

Protocolo HTTP: É o conjunto de regras que possibilita a comunicação em APIs na web (requisições e respostas).

curl: Uma ferramenta de linha de comando essencial para interagir e testar APIs diretamente, enviando requisições HTTP sem a necessidade de um navegador.

Breaking Changes: Uma mudança em uma API que quebra a integração para quem já a utiliza (ex: renomear um campo). Exige cuidado e versionamento (v1 -> v2).

Non-Breaking Changes: Uma mudança que não quebra a integração (ex: adicionar um novo campo opcional).

3. A Mentalidade Chave: Nada é Mágico
Esta é a lição que conecta tudo e eleva um profissional:

Entender como as tecnologias funcionam "por dentro" é mais importante do que apenas usá-las.

Achar que as ferramentas e processos funcionam por "magia" limita sua capacidade de resolver problemas complexos. Um profissional de destaque se diferencia pela curiosidade de desmontar a "caixa-preta", seja para entender melhor os protocolos de comunicação (HTTP), as ferramentas de teste (curl) ou as estratégias de qualidade (Pirâmide de Testes). Essa profundidade de conhecimento é o que realmente solidifica o aprendizado e a sua eficácia.





A maior briga no universo dos Testes Automatizados
Testes Automatizados é um assunto tão importante quanto ele é passível de gerar briga na internet e nessa aula eu vou mostrar o motivo. É muito importante você estar preparado para esse tipo de discussão, principalmente sobre a diferença entre testes unitários, integração e e2e 💪

Pergunta
Qual a sua definição sobre os tipos de teste que existem?

Resposta
Acredito que o meio termo seja o caminho como foi ensinado na aula.

Anotações:

Issue: Banco de dados (homologação e produção) #11

-[] Criar endpoint `/status`
-[] Subir Banco de Dados (Local)
-[] Criar módulo `database.js`

O debate sobre qual tipo de teste é "melhor" é comum porque cada um oferece um tipo diferente de confiança e possui custos distintos. A chave, como visto na aula, é encontrar um equilíbrio que funcione para o projeto, em vez de seguir um dogma.

1. A Hierarquia dos Testes

Pirâmide de Testes (Modelo Clássico): Propõe uma base larga de testes rápidos e baratos, e um topo estreito de testes lentos e caros.
  * Unit (Unitários): Testa uma única função ou componente de forma isolada. Rápido, mas não garante que o sistema funciona como um todo.
  
  * Integration (Integração): Testa como duas ou mais partes do sistema interagem. Ex: Testa se a API consegue se comunicar com o banco de dados. Fornece mais confiança que um teste unitário.

  * E2E (Ponta-a-Ponta): Simula a jornada completa do usuário através da interface gráfica (UI). É o teste que dá mais confiança, porém é o mais lento, caro e frágil.

2. Alternativas e a Tendência "API First"

Troféu de Teste / Favo de Mel: São modelos alternativos que questionam a hegemonia dos testes unitários e dão maior ênfase aos testes de integração.

API First: Uma abordagem que prioriza o desenvolvimento e o teste da API. Nesse cenário, os testes de integração se tornam o foco principal, pois garantem que os contratos da API e suas conexões com outros serviços (como o banco de dados) são confiáveis.

3. Passos Práticos para um Teste de Integração
As anotações práticas são um exemplo de como construir um teste de integração para um endpoint que verifica a "saúde" da conexão com o banco de dados:

  * Criar o módulo database.js: Isola a lógica de conexão com o banco de dados.

  * Subir o Banco de Dados (Local): Preparar o ambiente para que o teste possa interagir com um banco de dados real.

  * Criar o endpoint /status: Um endpoint na API que, ao ser acessado, irá utilizar o módulo database.js para verificar o status da conexão, provando que a integração entre a API e o banco está funcionando.




Encostando a mão no Protocolo HTTP 🔥
Essa aula vai ser muito massa, porque eu e você vamos encostar a mão no protocolo HTTP e isso não somente vai esclarecer na sua mente muita coisa sobre tudo o que existe na internet, como também vai ser a base para conseguir entender de fato (ou revisitar) muita coisa importante como: cookies, cabeçalhos, status codes, mas tirando toda a magia de onde esses dados vem, e tudo isso vai colocar você um passo mais próximo da senioridade, ou pelo menos, vai fazer você conseguir ter conversas sérias, muito mais avançadas e certeiras quando o contexto pedir por uma pessoa que tenha maturidade e experiência nesse assunto.

Anotações:

O objetivo desta aula é remover a "magia" do funcionamento da internet, entendendo na prática como o protocolo HTTP funciona. Esse conhecimento é a base para dominar tópicos como APIs, cabeçalhos e status codes, e é um passo fundamental para a senioridade técnica.

1. O Papel das Interfaces e Abstrações
API (Interface de Programação de Aplicações): O princípio fundamental é que "tudo é uma interface". Seja uma interface de usuário (gráfica) ou uma interface programável (API), o objetivo é o mesmo.

Abstração: Interfaces são uma forma de abstração. Elas nos permitem usar uma funcionalidade sem precisar conhecer os detalhes de sua implementação interna. Elas definem um "contrato" de como interagir com um sistema.

2. Criando um Endpoint de API com Next.js
File-based Routing: No Next.js, o roteamento é baseado em arquivos. Ao criar um arquivo dentro da pasta /pages/api/, ele automaticamente se torna um endpoint de API público.

Exemplo (/pages/api/status.js): Um arquivo que exporta uma função se torna um "ponto final" onde um cliente pode fazer uma requisição.

``` JavaScript

// A função recebe dois objetos principais:
// request: Contém os dados da requisição que chega.
// response: Contém os métodos para construir e enviar a resposta.
function status(request, response) {
  // .status(200) define o HTTP Status Code para "OK".
  // .json({}) envia uma resposta no formato JSON.
  response.status(200).json({ status: "ok" });
}

export default status;

```

3. A Diferença entre .send() e .json()
O método .send() envia os dados, mas não especifica o tipo de conteúdo ou o charset.

O método .json() é mais inteligente: ele automaticamente define o cabeçalho (Header) da resposta para Content-Type: application/json; charset=utf-8, informando ao cliente como interpretar os dados recebidos.

4. "Encostando a Mão" no HTTP com curl
curl é uma ferramenta de linha de comando para fazer requisições HTTP, permitindo ver a comunicação "crua" entre cliente e servidor.

Comando: curl http://localhost:3000/api/status --verbose (ou -v).

A flag --verbose: Revela todos os detalhes da transação HTTP que normalmente ficam ocultos.

> (Request): Mostra os cabeçalhos que o seu cliente (curl) enviou para o servidor.

< (Response): Mostra os cabeçalhos que o servidor enviou de volta como resposta.

* (Curl Internals): Mostra informações sobre o processo de conexão que o curl está executando.

Usar o curl --verbose é a forma prática de ver os cabeçalhos (como o Content-Type) e os status codes (como o 200) em ação, transformando teoria em conhecimento concreto.



Não é magia! (é Protocolo)
Eu sugiro você ter um único objetivo com estas aulas mais recentes, que é acreditar que, na area de tecnologia ou na programação num geral, não existe magia... não existe mesmo! Toda informação está em algum lugar e você pode não conhecer esse lugar e naturalmente assumir que é um local mágico, mas não é.

Então nesta aula nós iremos cavucar um pouco mais o Protocolo HTTP na procura de informações que muitas pessoas encaram como "mágicas" 💪

Anotações:

O objetivo é provar que não existe "magia" em tecnologia. Toda informação está em algum lugar, e entender onde ela está é o que diferencia um profissional. Nesta aula, o foco é entender como um servidor compartilhado sabe qual site deve entregar para o cliente.

1. O Problema: Um Servidor, Vários Sites (Virtual Hosts)

Servidor Simples: No passado, um único endereço de IP geralmente correspondia a um único site. Acessar o IP abria o site.

Virtual Host (Servidor Compartilhado): Hoje, é comum que um único servidor (com um só IP) hospede centenas ou milhares de sites diferentes (como os da Vercel).

A "Magia": Se vários domínios (ex: siteA.com, siteB.com) apontam para o mesmo IP, como o servidor sabe qual deles o usuário quer ver?

2. A Solução: O Cabeçalho Host do Protocolo HTTP
A resposta não é mágica, está dentro do protocolo HTTP.

Quando você acessa um site, seu navegador primeiro usa o DNS para descobrir o IP do servidor daquele domínio.

Em seguida, ele envia uma requisição HTTP para esse IP. Dentro dessa requisição, existe um cabeçalho (header) chamado Host.

O valor do cabeçalho Host é o domínio que você digitou (ex: Host: siteA.com).

O servidor da Vercel (ou qualquer outro com Virtual Hosts) lê este cabeçalho Host para saber qual dos múltiplos sites que ele hospeda deve ser entregue ao cliente.

3. Provando o Conceito com curl

Podemos simular esse processo manualmente para provar que é o cabeçalho Host que comanda a operação.

Comando: curl ip_do_servidor --insecure --verbose --header 'Host: nome_do_site.com'

Análise do Comando:

curl ip_do_servidor: Faz a requisição diretamente ao IP do servidor, pulando a etapa do DNS.

--header 'Host: nome_do_site.com': Aqui está o segredo. Estamos manualmente adicionando o cabeçalho HTTP, dizendo ao servidor qual site queremos acessar.

--insecure: Necessário porque o certificado de segurança (HTTPS) geralmente está associado ao domínio, e não ao IP. Sem essa flag, o curl daria um erro de certificado.

--verbose: Exibe todos os detalhes da requisição e da resposta, permitindo ver o cabeçalho Host que enviamos em ação.

Este exercício prático demonstra que a seleção do site não é mágica, mas sim o resultado da leitura de uma informação clara e acessível enviada através do protocolo HTTP.







Versionamento de API e Endpoint "/status"
A aula de hoje tem muito mais conteúdos sobre API e HTTP, mas ela um objetivo muito claro e que já está super encaminhado, que é completar a tarefa Criar endpoint /status, e em cima disto iremos aprender sobre Versionamento de API e Breaking Changes 🤝

Anotações:

Evoluir uma API é um processo delicado. É preciso adicionar novas funcionalidades sem quebrar a integração para os clientes que já a utilizam. A chave para isso é uma boa estratégia de versionamento.

1. O Contrato da API: Breaking vs. Non-Breaking Changes
Non-Breaking Change: Uma mudança aditiva, como adicionar uma nova propriedade à resposta. O consumidor deve estar preparado para receber mais dados do que o esperado sem quebrar.

Breaking Change: Uma mudança que quebra a compatibilidade com versões anteriores (ex: renomear ou remover uma propriedade). O fornecedor da API precisa de uma estratégia para introduzir essas mudanças.

Estratégias de Versionamento: As mais comuns são via URL (URI Path Versioning) ou via cabeçalho HTTP (Header Versioning). A aula foca na primeira.

2. Implementando o Versionamento via URL (Path Versioning)
A abordagem é criar um "prefixo" na URL que indica a versão da API.

Estrutura de Pastas:

Dentro da pasta /pages/api, cria-se uma pasta para a versão: /v1.

A lógica do endpoint (o antigo status.js) é movida para dentro da nova estrutura, resultando em: pages/api/v1/status/index.js.

Resultado: O endpoint, que antes era /api/status, agora se torna /api/v1/status, indicando claramente que esta é a versão 1.

3. Testando o Endpoint Versionado
É crucial garantir que a nova URL funcione como esperado.

Organização dos Testes: A estrutura de pastas dos testes de integração (/integration) deve espelhar a da API: integration/api/v1/status/get.test.js.

Código do Teste (get.test.js):

``` JavaScript

// No protocolo HTTP, é preciso especificar o método (GET, POST, etc.)
test("GET to /api/v1/status should return 200", async () => {
  const response = await fetch("http://localhost:3000/api/v1/status");
  expect(response.status).toBe(200);
});

Observação sobre async/await:
A função fetch realiza uma operação de rede, que é assíncrona (não acontece instantaneamente). Ela retorna uma Promise (promessa) de uma resposta futura.
await é usado para pausar a execução da função até que a Promise do fetch seja resolvida (ou seja, até a resposta chegar).

Toda função que usa await precisa ser declarada como async.

4. Limpeza do Projeto
"Deletar a pasta de teste unitários e o arquivo da calculadora": Este passo simboliza a evolução do projeto. O foco sai de exemplos didáticos (testes unitários de uma calculadora) e passa para testes mais realistas e de maior valor para o projeto: os testes de integração da API.