### Git e GitHub

# O que √© Git?

O Git √© um sistema de controle de vers√£o distribu√≠do, gratuito e de c√≥digo aberto, que permite rastrear e gerenciar as altera√ß√µes em um projeto de software ao longo do tempo. Ele foi criado por Linus Torvalds em 2005. O Git √© uma ferramenta essencial para desenvolvedores, facilitando a colabora√ß√£o em projetos, a cria√ß√£o de vers√µes e a revers√£o de altera√ß√µes caso necess√°rio. 

O Git √© como se fosse um v√≠deo no meu computador.

# O que √© GitHub?

O GitHub √© uma plataforma online que funciona como um grande reposit√≥rio de c√≥digo de programa√ß√£o, onde desenvolvedores podem armazenar, compartilhar e colaborar em projetos. √â essencialmente uma rede social para programadores, facilitando o trabalho em equipe e a colabora√ß√£o em projetos de c√≥digo aberto. 

O GitHub √© como o YouTube, uma plataforma que posso compartilhar ou assistir outros videos.

Para criar uma conta no GitHub: https://docs.github.com/pt/get-started/start-your-journey/creating-an-account-on-github

Para criar um reposit√≥rio no GitHub: https://docs.github.com/pt/repositories/creating-and-managing-repositories/creating-a-new-repository

### Codespaces

# O que √© codespaces?

Um codespace √© um ambiente de desenvolvimento virtual e hospedado na nuvem, oferecido pelo GitHub. Permite que os desenvolvedores escrevam, testem e depurem c√≥digo diretamente na nuvem, sem a necessidade de configura√ß√µes locais complexas. 

Como criar um codespace para um reposit√≥rio: https://docs.github.com/pt/codespaces/developing-in-a-codespace/creating-a-codespace-for-a-repository

### Aten√ß√£o

Aprenda a fun√ß√£o das coisas, n√£o se preenda a gostos pessoais.

### Anota√ß√µes pessoais

O Git √© um controlador de vers√µes, ele cria e gerencia v√°rias vers√µes do projeto. Ele faz uma c√≥pia sempre que voc√™ o chama, n√£o copiando totalmente, mas indicando as altera√ß√µes que foram realizadas em cada vers√£o.

O GitHub √© uma rede social, no qual posso compartilhar projetos, acessar, editar, copiar e interagir com projetos de outras pessoas.

O codespaces √© um espa√ßo para eu desenvolver meus projetos, ele cria uma m√°quina virtual com o vscode e um terminal, no qual me permite desenvolver sem as limita√ß√µes de um computador f√≠sico mais modesto.

### Refer√™ncias:

https://www.atlassian.com/br/git/tutorials/what-is-git
https://docs.github.com/pt/get-startedstart-your-journey/about-github-and-git
https://docs.github.com/pt/codespaces/about-codespaces/what-are-codespaces

#################################

"Se voc√™ quiser fazer uma torta de ma√ß√£ a partir do zero, voc√™ deve primeiro inventar o Universo." - Carl Sagan

N√£o √© poss√≠vel hoje come√ßar algo do zero, vamos precisar subir no ombro de gigantes e al√ßar novos voos. Isso n√£o √© um problema, podemos fazer coisas incr√≠veis em comunidade.

### Node.js

# O que √© node.js

Node.js √© um ambiente de execu√ß√£o JavaScript do lado do servidor, que permite aos desenvolvedores criar aplica√ß√µes web, APIs, e outras ferramentas de linha de comando utilizando a linguagem JavaScript.

Node.js √© como uma cozinha que permite preparar receitas (aplica√ß√µes) usando um fog√£o (ambiente de execu√ß√£o) que entende a linguagem do JavaScript.

# Terminal 

Terminal √© uma interface de linha de comando que permite interagir com um sistema operacional atrav√©s de comandos digitados, sme a necissade de uma interface gr√°fica.

Terminal √© como um peda√ßo de papel, ele permite que voc√™ intereja com o sistema operacional, enquanto o shell √© o "motor" que interpreta e executa seus comandos.

# Shell

√â uma interface que permite aos utilizadores interagir com um sistema operacional.

√â como a casca de um ovo, que protege o conte√∫do interno.

# NVM (Node Version Manager)

NVM √© uma ferramenta que permite aos desenvolvedores gerenciar v√°rias cers√µes do Node.js em um √∫nico sistema operacional.

# Para acessar os detalhes do NVM use:

nvm --help (node version manager ajuda)

### Como instalar uma vers√£o espec√≠fica do Node.js?

1¬∫ Vamos precisar listar as vers√µes disponiveis,vamos usar o comando: 

nvm ls (node version manager list)

2¬∫ Escolha a vers√£o, por exemplo lts/hydrogen, para isso use os comandos:

nvm install lts/hydrogen (node version manager install version)

### Como deixar a vers√£o anterior como padr√£o

Para isso vamos precisar definir como padr√£o a vers√£o deseja, conforme abaixo:

nvm alias default <version> (node version manager apelido padr√£o vers√£o)

### Declarar a vers√£o utilizada no projeto

Para deixar claro para outras pessoas e padronizar o projeto, precisamos deixar claro qual vers√£o do node vai ser utilizado, fazemos isso da forma abaixo:

1¬∫ Crie o arquivo abaixo na pasta raiz do projeto.
.nvmrc (node version manager run commands)

2¬∫ Dentro escreva a vers√£o desejada e pule uma linha.

Exemplo:
"
lts/hydrogen

"

### Next.js

√â um framework React para construir aplica√ß√µes web, que fornece uma estrutura e recursos extras para otimizar o desenvolvimento e melhorar o desempenho das aplica√ß√µes.

√â como um motor que facilita a constru√ß√£o de aplica√ß√µes web com React.

Tamb√©m para o Next e o React, √© necess√°rio indicar no projeto quais vers√µes foram utilizadas. Para isso vamos:

1¬∫ Precisamos inicializar o node no nosso projeto e esse comando vai criar um arquivo package.json, usamos o comando:

npm init (node package manager initialize)

2¬∫ Vamos escolher a vers√£o do next.js que ser√° utilizado, nesse exemplo vamos usar a vers√£o 13.1.6:

npm install next@13.1.6 (node package manager install <version>)

### React

√â uma biblioteca JavaScript de software livre, popularmente utilizada para construir interfaces de usu√°rio do lado do cliente (front-end).

√â como um sistema de blocos de constru√ß√£o para interfaces de usu√°rio, onde cada bloco (componente) pode ser utilizado e combinado para criar aplica√ß√µes complexas.

√â necess√°rio instalar a vers√£o do react, nesse exemplo √© a 18.2.0:

npm install react@18.2.0 (node package install <version>)

O ponto √© que o React foi separado entre seu core e suas renderiza√ß√µes, pois ele √© extremamente vasto.

Para HTML, quem renderiza √© o DOM, para isso vamos instalar a vers√£o do react DOM, para manipula-lo:

npm install react-dom@18.2.0 (node package install <version>)






O que √© um servi√ßo web?

Protocolos

HTTP
FTP
SMTP
UDP
IP

UDP TCP

next dev
"dev": "next dev"


Ctrl + L

pages

index.js 

function Home() {
    return <h1>Teste</h1>
}

export default Home;

deploy



#################
Control History

Versionamento de c√≥digo

sccs -> rcs -> cvs -> svn -> git
       centralizado        | distribu√≠do

Merge

Merge conflict

Clone

ls -la

.git

Diff

Delta encoding

Blob

git log

Commit


3 est√°gios

1 - Modified
2 - Staged
3 - Commit

git log --stat

git status

Unstrack file

Build

.gitignore

git add nome do arquivo

git commit



git log --oneline

Working Directory

Diff

git diff

Newline

Amend

git commit --amend 

Gits s√£o imut√°veis












origin/main

branch

git push

pull

git commit -m "Mensagem"

git push --force ou --f







Continuos deployment

Client / Server


Hospedagem de site

Deploy

Continuos integration -> Build


Principle least privilege

Cada commit deployado, kkk, tem uma url unica









N1: Ser lembrado indivualmente; (Anotar tarefas no papel, em cima da mesa)
N2: Ser lembrado em grupo; (Quadro kambam)
N3: Expandir conhecimento; (Trello ou Github)
N4: Gerar metas. (Jira)


Issue inception

Milestones
    - Milestone 0: Em constru√ß√£o

Est√°gio 1 - In√≠cio
Est√°gio 2 - Progresso
Est√°gio 3 - Conclus√£o

Issues: 

Colocar o site num dom√≠nio .com.br
Definir estiliza√ß√£o do c√≥digo e configurar editor
Programar p√°gina de "Em constru√ß√£o"










Estiliza√ß√£o de c√≥digo √© essencial

- [ ] - Ligar sincroniza√ß√£o do editor
- [ ] - Configurar o EditorConfig
- [ ] - Configurar o Prettier


EditorConfig

.EditorConfig

root = true

[*] 
indent_style = space
indent_size = 2


Prettier / Standard js

npm install prettier -D ou --save-dev


no package.json
"lint:check": "prettier --check ."
"lint:fix": "prettier --write ."







DNS 2 - n√≠veis

IP √© o endere√ßo de cada computador

DNS √© um apelido

DNS <- Computador -> servidor
    ->

Recursive Resolver <- Computador
                    ->

Recursive Resolver -> Root Server
                   <-
                   -> TLD 
                   <-
                   -> Authoritative Server

FQDN

Root Domain - TLD - Authoritative Server - TTL
            ccTLD/gTLD












### Dia 12 - DNS (Pr√°tica)

Task da insue "Coloca o site num dom√≠nio .com.br"

- [ ] - Registrar dom√≠nio pr√≥prio
- [ ] - Configurar Servidor de DNS

Registrant -> Registrar -> Registry -> TLD

whatismydns -> NS

vieirarodrigo.com.br


Dizer para vercel o nosso dom√≠nio

Dizer para a TLD o nosso DNS


### Git e GitHub

# O que √© Git?

O Git √© um sistema de controle de vers√£o distribu√≠do, gratuito e de c√≥digo aberto, que permite rastrear e gerenciar as altera√ß√µes em um projeto de software ao longo do tempo. Ele foi criado por Linus Torvalds em 2005. O Git √© uma ferramenta essencial para desenvolvedores, facilitando a colabora√ß√£o em projetos, a cria√ß√£o de vers√µes e a revers√£o de altera√ß√µes caso necess√°rio. 

O Git √© como se fosse um v√≠deo no meu computador.

# O que √© GitHub?

O GitHub √© uma plataforma online que funciona como um grande reposit√≥rio de c√≥digo de programa√ß√£o, onde desenvolvedores podem armazenar, compartilhar e colaborar em projetos. √â essencialmente uma rede social para programadores, facilitando o trabalho em equipe e a colabora√ß√£o em projetos de c√≥digo aberto. 

O GitHub √© como o YouTube, uma plataforma que posso compartilhar ou assistir outros videos.

Para criar uma conta no GitHub: https://docs.github.com/pt/get-started/start-your-journey/creating-an-account-on-github

Para criar um reposit√≥rio no GitHub: https://docs.github.com/pt/repositories/creating-and-managing-repositories/creating-a-new-repository

### Codespaces

# O que √© codespaces?

Um codespace √© um ambiente de desenvolvimento virtual e hospedado na nuvem, oferecido pelo GitHub. Permite que os desenvolvedores escrevam, testem e depurem c√≥digo diretamente na nuvem, sem a necessidade de configura√ß√µes locais complexas. 

Como criar um codespace para um reposit√≥rio: https://docs.github.com/pt/codespaces/developing-in-a-codespace/creating-a-codespace-for-a-repository

### Aten√ß√£o

Aprenda a fun√ß√£o das coisas, n√£o se preenda a gostos pessoais.

### Anota√ß√µes pessoais

O Git √© um controlador de vers√µes, ele cria e gerencia v√°rias vers√µes do projeto. Ele faz uma c√≥pia sempre que voc√™ o chama, n√£o copiando totalmente, mas indicando as altera√ß√µes que foram realizadas em cada vers√£o.

O GitHub √© uma rede social, no qual posso compartilhar projetos, acessar, editar, copiar e interagir com projetos de outras pessoas.

O codespaces √© um espa√ßo para eu desenvolver meus projetos, ele cria uma m√°quina virtual com o vscode e um terminal, no qual me permite desenvolver sem as limita√ß√µes de um computador f√≠sico mais modesto.

### Refer√™ncias:

https://www.atlassian.com/br/git/tutorials/what-is-git
https://docs.github.com/pt/get-startedstart-your-journey/about-github-and-git
https://docs.github.com/pt/codespaces/about-codespaces/what-are-codespaces

#################################

"Se voc√™ quiser fazer uma torta de ma√ß√£ a partir do zero, voc√™ deve primeiro inventar o Universo." - Carl Sagan

N√£o √© poss√≠vel hoje come√ßar algo do zero, vamos precisar subir no ombro de gigantes e al√ßar novos voos. Isso n√£o √© um problema, podemos fazer coisas incr√≠veis em comunidade.

### Node.js

# O que √© node.js

Node.js √© um ambiente de execu√ß√£o JavaScript do lado do servidor, que permite aos desenvolvedores criar aplica√ß√µes web, APIs, e outras ferramentas de linha de comando utilizando a linguagem JavaScript.

Node.js √© como uma cozinha que permite preparar receitas (aplica√ß√µes) usando um fog√£o (ambiente de execu√ß√£o) que entende a linguagem do JavaScript.

# Terminal 

Terminal √© uma interface de linha de comando que permite interagir com um sistema operacional atrav√©s de comandos digitados, sme a necissade de uma interface gr√°fica.

Terminal √© como um peda√ßo de papel, ele permite que voc√™ intereja com o sistema operacional, enquanto o shell √© o "motor" que interpreta e executa seus comandos.

# Shell

√â uma interface que permite aos utilizadores interagir com um sistema operacional.

√â como a casca de um ovo, que protege o conte√∫do interno.

# NVM (Node Version Manager)

NVM √© uma ferramenta que permite aos desenvolvedores gerenciar v√°rias cers√µes do Node.js em um √∫nico sistema operacional.

# Para acessar os detalhes do NVM use:

nvm --help (node version manager ajuda)

### Como instalar uma vers√£o espec√≠fica do Node.js?

1¬∫ Vamos precisar listar as vers√µes disponiveis,vamos usar o comando: 

nvm ls (node version manager list)

2¬∫ Escolha a vers√£o, por exemplo lts/hydrogen, para isso use os comandos:

nvm install lts/hydrogen (node version manager install version)

### Como deixar a vers√£o anterior como padr√£o

Para isso vamos precisar definir como padr√£o a vers√£o deseja, conforme abaixo:

nvm alias default <version> (node version manager apelido padr√£o vers√£o)

### Declarar a vers√£o utilizada no projeto

Para deixar claro para outras pessoas e padronizar o projeto, precisamos deixar claro qual vers√£o do node vai ser utilizado, fazemos isso da forma abaixo:

1¬∫ Crie o arquivo abaixo na pasta raiz do projeto.
.nvmrc (node version manager run commands)

2¬∫ Dentro escreva a vers√£o desejada e pule uma linha.

Exemplo:
"
lts/hydrogen

"

### Next.js

√â um framework React para construir aplica√ß√µes web, que fornece uma estrutura e recursos extras para otimizar o desenvolvimento e melhorar o desempenho das aplica√ß√µes.

√â como um motor que facilita a constru√ß√£o de aplica√ß√µes web com React.

Tamb√©m para o Next e o React, √© necess√°rio indicar no projeto quais vers√µes foram utilizadas. Para isso vamos:

1¬∫ Precisamos inicializar o node no nosso projeto e esse comando vai criar um arquivo package.json, usamos o comando:

npm init (node package manager initialize)

2¬∫ Vamos escolher a vers√£o do next.js que ser√° utilizado, nesse exemplo vamos usar a vers√£o 13.1.6:

npm install next@13.1.6 (node package manager install <version>)

### React

√â uma biblioteca JavaScript de software livre, popularmente utilizada para construir interfaces de usu√°rio do lado do cliente (front-end).

√â como um sistema de blocos de constru√ß√£o para interfaces de usu√°rio, onde cada bloco (componente) pode ser utilizado e combinado para criar aplica√ß√µes complexas.

√â necess√°rio instalar a vers√£o do react, nesse exemplo √© a 18.2.0:

npm install react@18.2.0 (node package install <version>)

O ponto √© que o React foi separado entre seu core e suas renderiza√ß√µes, pois ele √© extremamente vasto.

Para HTML, quem renderiza √© o DOM, para isso vamos instalar a vers√£o do react DOM, para manipula-lo:

npm install react-dom@18.2.0 (node package install <version>)






O que √© um servi√ßo web?

Protocolos

HTTP
FTP
SMTP
UDP
IP

UDP TCP

next dev
"dev": "next dev"


Ctrl + L

pages

index.js 

function Home() {
    return <h1>Teste</h1>
}

export default Home;

deploy



#################
Control History

Versionamento de c√≥digo

sccs -> rcs -> cvs -> svn -> git
       centralizado        | distribu√≠do

Merge

Merge conflict

Clone

ls -la

.git

Diff

Delta encoding

Blob

git log

Commit


3 est√°gios

1 - Modified
2 - Staged
3 - Commit

git log --stat

git status

Unstrack file

Build

.gitignore

git add nome do arquivo

git commit



git log --oneline

Working Directory

Diff

git diff

Newline

Amend

git commit --amend 

Gits s√£o imut√°veis












origin/main

branch

git push

pull

git commit -m "Mensagem"

git push --force ou --f







Continuos deployment

Client / Server


Hospedagem de site

Deploy

Continuos integration -> Build


Principle least privilege

Cada commit deployado, kkk, tem uma url unica









N1: Ser lembrado indivualmente; (Anotar tarefas no papel, em cima da mesa)
N2: Ser lembrado em grupo; (Quadro kambam)
N3: Expandir conhecimento; (Trello ou Github)
N4: Gerar metas. (Jira)


Issue inception

Milestones
    - Milestone 0: Em constru√ß√£o

Est√°gio 1 - In√≠cio
Est√°gio 2 - Progresso
Est√°gio 3 - Conclus√£o

Issues: 

Colocar o site num dom√≠nio .com.br
Definir estiliza√ß√£o do c√≥digo e configurar editor
Programar p√°gina de "Em constru√ß√£o"










Estiliza√ß√£o de c√≥digo √© essencial

- [ ] - Ligar sincroniza√ß√£o do editor
- [ ] - Configurar o EditorConfig
- [ ] - Configurar o Prettier


EditorConfig

.EditorConfig

root = true

[*] 
indent_style = space
indent_size = 2


Prettier / Standard js

npm install prettier -D ou --save-dev


no package.json
"lint:check": "prettier --check ."
"lint:fix": "prettier --write ."







DNS 2 - n√≠veis

IP √© o endere√ßo de cada computador

DNS √© um apelido

DNS <- Computador -> servidor
    ->

Recursive Resolver <- Computador
                    ->

Recursive Resolver -> Root Server
                   <-
                   -> TLD 
                   <-
                   -> Authoritative Server

FQDN

Root Domain - TLD - Authoritative Server - TTL
            ccTLD/gTLD












### Dia 12 - DNS (Pr√°tica)

Task da insue "Coloca o site num dom√≠nio .com.br"

- [ ] - Registrar dom√≠nio pr√≥prio
- [ ] - Configurar Servidor de DNS

Registrant -> Registrar -> Registry -> TLD

whatismydns -> NS

vieirarodrigo.com.br


Dizer para vercel o nosso dom√≠nio

Dizer para a TLD o nosso DNS


dig site A +trace





###  Dia 13 - 

As pessoas est√£o se aproximando ou se afastando?

Teoria McDonalds


99.9% Uptime
9h/Ano ou 44min/m√™s

SLA

Status Pages

vercel status ou aws status ou github status

RDS






### Dia 14 - Milestone 1: Funda√ß√£o

## D1 - Inaugura√ß√£o Milestone 1: Funda√ß√£o

Front-end

Milestone 1: Funda√ß√£o
  Proposta de arquitetura e pastas
  Testes automatizados
  Banco de dados (Local)
  Migrations
  Continuos Integration
  Linter de c√≥digo
  Linter de commits
  Banco de dados (homologa√ß√£o e produ√ß√£o)
  Tipo da licen√ßa


## D2 - Uma hist√≥ria macabra sobre "Overengineering"

Overengineering - Excesso de engenharia (Complexo)

Voc√™ quer estar aqui

Underengineering - (Simples e mal feito)

Um software deve ser modific√°vel


## D3 - Porposta de Arquitetura e pastas

1. Arquitetura de software

MVC - Model View Controler

2. Organiza√ß√£o das pastas e arquivos

root
  pages
    index.js
  models
    user.js
    content.js
    password.js
  infra
    database.js
    migration
    provisioning
      staging
      production
  tests

## D4 - B√¥nus: PoC e MVP ajudam mesmo?

PoC - Proof of Concept
MVP - Minimum Viable Product




### Dia 15 

## D1 - Testes Automatizados: um caminho sem volta

62 Aulas??

- [ ] - Instalar o Test Runner
- [ ] - Criar um Teste de Teste
- [ ] - Criar um Teste de Verdade

## D2 - Instalar um Test Runner

C√≥digo que executa C√≥digo

Mocha | AVA | Playwight | Jest

npm install --save-dev jest@29.6.2

"test": "jest"
"test:watch": "jest --watch"


## D3 - Criar um "Teste de Teste"

Programar uma calculadora

npm run test -watch

tests

calculadora.test.js

test("nome do teste", callbackFunction);

function callbackFunction() {
  console.log("esta fun√ß√£o est√° sendo chamada?")
}

test("nome do teste", function () {
  console.log("e assim, funciona?");
})

test("nome do teste", () => {
  console.log("e agora?");
});

test("outro teste", () => {
  console.log("outro teste");
});

Expect - Espera

test("espero que 1 seja 1", () => {
  espect(1).toBe(1);
});

Valor gerado dinamicamente | Valor esperado




## D4 - Criar um "Teste de Verdade"

No MVC

Criar ferramentas (Model)

CommonJS (ESM)

Trasnpilling

expect(resultado)
Softcoded

.toBe(4)
Hardcoded

Teste n√£o diz que o codigo est√° certo, mas que algo passou ou n√£o em um teste

TDD





Resumo: 

E a√≠, pessoal do Curso.Dev! Sejam muito bem-vindos a mais uma aula que vai mudar completamente a forma como voc√™s encaram o desenvolvimento de software. Eu sei que o Felipe j√° tocou na import√¢ncia disso, mas hoje, a gente vai mergulhar de cabe√ßa nos **Testes Automatizados: um caminho sem volta**! Preparem-se para uma sacada que vai acelerar a carreira de voc√™s.

Pensem comigo: no desenvolvimento de software moderno, testar manualmente cada altera√ß√£o de c√≥digo √© como tentar esvaziar o Oceano Atl√¢ntico com um balde. Invi√°vel e ineficiente, n√©? √â por isso que os testes automatizados s√£o um pilar fundamental, proporcionando confian√ßa, seguran√ßa e agilidade para o projeto. Eles garantem que, a cada nova funcionalidade ou corre√ß√£o, o comportamento esperado da aplica√ß√£o seja verificado de forma autom√°tica.

Vamos estruturar nossa aula em tr√™s etapas essenciais, seguindo a did√°tica que a gente tanto preza:

### 1. Instalar um Test Runner

Primeiro, a gente precisa de uma ferramenta para "rodar" nossos testes. Pensem no "Test Runner" como o maestro da orquestra dos seus testes. Ele √© um c√≥digo que procura os arquivos de teste no seu projeto, executa o que voc√™ escreveu e te apresenta um relat√≥rio claro do que passou e do que falhou. No ecossistema JavaScript, temos v√°rias op√ß√µes de peso no mercado, como Mocha, AVA, Playwright e, claro, o **Jest**.

O Jest, desenvolvido pelo Facebook e recomendado pela equipe do React, √© um dos frameworks de teste mais populares e poderosos para projetos JavaScript. Por que ele? Simplicidade de configura√ß√£o, execu√ß√£o r√°pida, mock integrado, suporte a ES6/TypeScript e uma comunidade ativa que √© um verdadeiro *dream team* para tirar d√∫vidas.

**Como a gente instala o Jest?** Moleza! Primeiro, se voc√™ ainda n√£o tem um projeto Node.js inicializado, comece com:

```bash
npm init -y
```
Depois, adicione o Jest como uma depend√™ncia de desenvolvimento (ou seja, ele s√≥ √© necess√°rio para quem vai desenvolver e testar, n√£o para a vers√£o final da aplica√ß√£o):

```bash
npm install --save-dev jest
```
Isso instala a ferramenta que vai fazer a m√°gica acontecer.

Agora, uma **sacada de produtividade**: vamos configurar os scripts no seu `package.json` para facilitar a vida. Abra o seu `package.json` e adicione (ou ajuste) a se√ß√£o `scripts` assim:

```json
// package.json
{
  ...
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch"
  },
  ...
}
```
Com `"test": "jest"`, voc√™ roda todos os testes do projeto uma vez com `npm test`. J√° o `"test:watch": "jest --watch"` √© um verdadeiro *game-changer* durante o desenvolvimento! Ele faz com que o Jest fique "escutando" as altera√ß√µes nos seus arquivos e, ao salvar, roda automaticamente apenas os testes relevantes, dando um feedback instant√¢neo. Isso √© agilidade pura!

### 2. Criar um "Teste de Teste" (Sanity Check)

Antes de testar a l√≥gica complexa da sua aplica√ß√£o, a gente sempre come√ßa com um "Teste de Teste" ou um *sanity check*. O objetivo aqui √© super simples: validar se o Jest foi configurado corretamente e se ele est√° conseguindo encontrar e executar os arquivos de teste. √â a prova de vida do seu ambiente de testes!

Para isso, o Jest automaticamente reconhece arquivos com a extens√£o `.test.js` (ou `.spec.js`) como arquivos de teste. Uma estrutura comum para o seu projeto seria ter uma pasta `src` para o seu c√≥digo e uma pasta `tests` para os seus testes.

Vamos criar um arquivo dentro da sua pasta `tests`, por exemplo, `meuprimeiro.test.js`:

```javascript
// meuprimeiro.test.js
test("espero que 1 seja 1", () => {
  // expect(valor_gerado).toBe(valor_esperado);
  expect(1).toBe(1);
});
```

A fun√ß√£o `test()` define um teste individual, recebendo uma descri√ß√£o em string e uma fun√ß√£o *callback* com a l√≥gica do teste. E o cora√ß√£o do teste? √â a fun√ß√£o `expect()` combinada com um "matcher" como o `.toBe()`. O `expect(valor_dinamico).toBe(valor_esperado)` √© a forma de afirmar que o resultado do seu c√≥digo (`valor_dinamico`) √© exatamente igual ao que voc√™ esperava (`valor_esperado`).

Agora, execute seu "Teste de Teste" no terminal:

```bash
npm test
```

Se tudo deu certo, voc√™ ver√° uma sa√≠da parecida com esta:

```
PASS tests/meuprimeiro.test.js
‚úì espero que 1 seja 1 (x ms)
```
Isso confirma que seu ambiente de testes est√° funcionando perfeitamente! Palmas para voc√™s!

### 3. Criar um "Teste de Verdade"

Com o ambiente validado, √© hora de testar uma funcionalidade real da sua aplica√ß√£o. Vamos pegar um exemplo cl√°ssico, como testar uma fun√ß√£o `soma` em um arquivo `funcoes.js`.

Se voc√™ estiver seguindo padr√µes como MVC (Model-View-Controller), essa fun√ß√£o estaria na sua camada de Model, onde ficam as regras de neg√≥cio.

Primeiro, crie o arquivo `src/funcoes.js` com a sua fun√ß√£o:

```javascript
// src/funcoes.js
function soma(a, b) {
  return a + b;
}

module.exports = { soma }; // Usando CommonJS para exportar
```
**Aten√ß√£o aqui!** Para o arquivo de teste poder acessar sua fun√ß√£o `soma`, voc√™ precisa export√°-la. Usamos `module.exports` e `require` para m√≥dulos CommonJS, que √© o padr√£o mais comum em projetos Node.js mais antigos e √© o que o Jest usa por padr√£o. Se voc√™ estivesse em um projeto mais moderno com ES Modules (ESM), usaria `export` e `import`, mas isso pode exigir alguma configura√ß√£o adicional, como um *transpiler* tipo Babel, para garantir compatibilidade com ambientes que ainda n√£o suportam ESM nativamente. No nosso caso simples, `module.exports` e `require` funcionam direto com Jest.

Agora, crie o arquivo de teste `tests/funcoes.test.js`:

```javascript
// tests/funcoes.test.js
const { soma } = require('../src/funcoes'); // Importando a fun√ß√£o a ser testada

test('soma dois n√∫meros', () => {
  expect(soma(1, 2)).toBe(3);
});

test('soma n√∫meros negativos', () => {
  expect(soma(-1, -2)).toBe(-3);
});

test('soma com zero', () => {
  expect(soma(5, 0)).toBe(5);
});
```

Execute novamente `npm test` e veja a m√°gica acontecer! Voc√™ ver√° todos os seus testes passando.

Uma "sacada" important√≠ssima sobre testes √© a diferen√ßa entre valores "hardcoded" e "softcoded".
*   **Hardcoded (Valor Fixo):** √â o valor que voc√™ escreve diretamente no teste como o resultado esperado. No exemplo `expect(resultado).toBe(4);`, o `4` √© *hardcoded*. Isso √© fundamental em testes unit√°rios, pois voc√™ quer garantir que uma entrada espec√≠fica sempre gere uma sa√≠da espec√≠fica e previs√≠vel.
*   **Softcoded (Valor Din√¢mico):** Refere-se ao valor gerado pelo seu c√≥digo, como a vari√°vel `resultado` em `expect(resultado)`. Esse valor √© din√¢mico e ser√° comparado com o valor *hardcoded* que voc√™ espera.

**Filosofia do Teste:** Entendam bem isso: um teste que passa *n√£o prova* que seu c√≥digo est√° 100% certo. Ele apenas prova que, para a *situa√ß√£o espec√≠fica* que voc√™ testou, o c√≥digo se comportou como o esperado. Se a sua fun√ß√£o `soma` fosse `return 4;`, o teste `soma(1,2).toBe(3)` falharia, mas `soma(2,2).toBe(4)` passaria ‚Äì o que mostra a necessidade de m√∫ltiplos casos de teste para ter confian√ßa.

Isso nos leva a uma metodologia poderosa: o **TDD - Test-Driven Development (Desenvolvimento Guiado por Testes)**. O ciclo √© simples, mas revolucion√°rio:
1.  **Red (Vermelho):** Escreva um teste para uma funcionalidade que ainda n√£o existe. Rode o teste e veja-o falhar.
2.  **Green (Verde):** Escreva o *m√≠nimo* de c√≥digo poss√≠vel para fazer o teste passar.
3.  **Refactor (Refatorar):** Melhore o c√≥digo que voc√™ escreveu sem alterar seu comportamento, garantindo que o teste continue passando.

Essa abordagem n√£o s√≥ garante que seu c√≥digo esteja coberto por testes desde o in√≠cio, mas tamb√©m incentiva a cria√ß√£o de um c√≥digo mais simples, modular e f√°cil de manter!

Para ir al√©m, voc√™s podem at√© gerar relat√≥rios de **cobertura de c√≥digo** com Jest. Basta adicionar `--coverage` ao script de teste no `package.json`:

```json
// package.json
{
  ...
  "scripts": {
    "test": "jest --coverage"
  },
  ...
}
```
Ao rodar `npm test` novamente, o Jest vai gerar um relat√≥rio detalhado mostrando a porcentagem do seu c√≥digo que est√° sendo coberta pelos testes. Isso √© crucial para entender qu√£o "testado" seu c√≥digo realmente est√°.

√â isso, pessoal! Voc√™s deram os primeiros passos s√≥lidos em testes automatizados com Jest. Lembrem-se: testes n√£o s√£o um custo, s√£o um **investimento** na qualidade e na sustentabilidade do seu software. Continuem explorando e testando sem medo! E qualquer d√∫vida, podem me procurar, porque aqui no Curso.Dev, a gente n√£o deixa ningu√©m para tr√°s. Bons c√≥digos!


Dia 16: 

üöó Pista R√°pida: Dia 16

O Dia 16 √© mais um daqueles dias especiais aqui no curso.dev porque mistura parte te√≥rica, parte pr√°tica e tamb√©m como ser um profissional melhor. E eu diria que esta √∫ltima parte de ser um profissional melhor √© o que faz grudar na sua mente a parte te√≥rica e pr√°tica, tanto que no final dessa Pista R√°pida aqui eu adicionei uma mensagem extra que eu n√£o coloquei em nenhuma Pista Lenta üí™

Anota√ß√µes:

Este dia focou em como garantir a qualidade e a comunica√ß√£o em software, culminando em uma li√ß√£o fundamental sobre como abordar a tecnologia.

1. Estrat√©gia de Testes: Garantindo a Qualidade
A qualidade do software √© verificada atrav√©s de diferentes tipos de testes, organizados estrategicamente.

Pir√¢mide de Testes: √â o modelo cl√°ssico para pensar em testes.
  * Base (Testes Unit√°rios): Testam a menor parte do c√≥digo (uma fun√ß√£o, um componente) de forma isolada. S√£o r√°pidos, baratos e devem existir em grande quantidade.
  
  * Meio (Testes de Integra√ß√£o): Verificam se diferentes unidades do sistema funcionam corretamente juntas. Exemplo: testar se a API, ao ser chamada, consegue de fato gravar os dados no banco de dados. S√£o mais lentos e complexos que os testes unit√°rios.
  
  * Topo (Testes de Ponta-a-Ponta): Simulam a jornada completa do usu√°rio na aplica√ß√£o. S√£o os mais lentos e caros.

Alternativas: Existem outros modelos al√©m da pir√¢mide (como o "favo de mel"), mas o princ√≠pio de ter uma estrat√©gia com diferentes camadas de teste permanece.

2. APIs: A Linguagem da Comunica√ß√£o entre Sistemas
Os testes de integra√ß√£o frequentemente validam a comunica√ß√£o entre diferentes partes de um sistema, que ocorre via APIs.

API (Interface de Programa√ß√£o de Aplica√ß√µes): √â um contrato que define como um software "conversa" com outro. O conceito de "interface" √© universal: pode ser uma interface gr√°fica (para um humano) ou uma interface program√°tica (para outro sistema).

Protocolo HTTP: √â o conjunto de regras que possibilita a comunica√ß√£o em APIs na web (requisi√ß√µes e respostas).

curl: Uma ferramenta de linha de comando essencial para interagir e testar APIs diretamente, enviando requisi√ß√µes HTTP sem a necessidade de um navegador.

Breaking Changes: Uma mudan√ßa em uma API que quebra a integra√ß√£o para quem j√° a utiliza (ex: renomear um campo). Exige cuidado e versionamento (v1 -> v2).

Non-Breaking Changes: Uma mudan√ßa que n√£o quebra a integra√ß√£o (ex: adicionar um novo campo opcional).

3. A Mentalidade Chave: Nada √© M√°gico
Esta √© a li√ß√£o que conecta tudo e eleva um profissional:

Entender como as tecnologias funcionam "por dentro" √© mais importante do que apenas us√°-las.

Achar que as ferramentas e processos funcionam por "magia" limita sua capacidade de resolver problemas complexos. Um profissional de destaque se diferencia pela curiosidade de desmontar a "caixa-preta", seja para entender melhor os protocolos de comunica√ß√£o (HTTP), as ferramentas de teste (curl) ou as estrat√©gias de qualidade (Pir√¢mide de Testes). Essa profundidade de conhecimento √© o que realmente solidifica o aprendizado e a sua efic√°cia.





A maior briga no universo dos Testes Automatizados
Testes Automatizados √© um assunto t√£o importante quanto ele √© pass√≠vel de gerar briga na internet e nessa aula eu vou mostrar o motivo. √â muito importante voc√™ estar preparado para esse tipo de discuss√£o, principalmente sobre a diferen√ßa entre testes unit√°rios, integra√ß√£o e e2e üí™

Pergunta
Qual a sua defini√ß√£o sobre os tipos de teste que existem?

Resposta
Acredito que o meio termo seja o caminho como foi ensinado na aula.

Anota√ß√µes:

Issue: Banco de dados (homologa√ß√£o e produ√ß√£o) #11

-[] Criar endpoint `/status`
-[] Subir Banco de Dados (Local)
-[] Criar m√≥dulo `database.js`

O debate sobre qual tipo de teste √© "melhor" √© comum porque cada um oferece um tipo diferente de confian√ßa e possui custos distintos. A chave, como visto na aula, √© encontrar um equil√≠brio que funcione para o projeto, em vez de seguir um dogma.

1. A Hierarquia dos Testes

Pir√¢mide de Testes (Modelo Cl√°ssico): Prop√µe uma base larga de testes r√°pidos e baratos, e um topo estreito de testes lentos e caros.
  * Unit (Unit√°rios): Testa uma √∫nica fun√ß√£o ou componente de forma isolada. R√°pido, mas n√£o garante que o sistema funciona como um todo.
  
  * Integration (Integra√ß√£o): Testa como duas ou mais partes do sistema interagem. Ex: Testa se a API consegue se comunicar com o banco de dados. Fornece mais confian√ßa que um teste unit√°rio.

  * E2E (Ponta-a-Ponta): Simula a jornada completa do usu√°rio atrav√©s da interface gr√°fica (UI). √â o teste que d√° mais confian√ßa, por√©m √© o mais lento, caro e fr√°gil.

2. Alternativas e a Tend√™ncia "API First"

Trof√©u de Teste / Favo de Mel: S√£o modelos alternativos que questionam a hegemonia dos testes unit√°rios e d√£o maior √™nfase aos testes de integra√ß√£o.

API First: Uma abordagem que prioriza o desenvolvimento e o teste da API. Nesse cen√°rio, os testes de integra√ß√£o se tornam o foco principal, pois garantem que os contratos da API e suas conex√µes com outros servi√ßos (como o banco de dados) s√£o confi√°veis.

3. Passos Pr√°ticos para um Teste de Integra√ß√£o
As anota√ß√µes pr√°ticas s√£o um exemplo de como construir um teste de integra√ß√£o para um endpoint que verifica a "sa√∫de" da conex√£o com o banco de dados:

  * Criar o m√≥dulo database.js: Isola a l√≥gica de conex√£o com o banco de dados.

  * Subir o Banco de Dados (Local): Preparar o ambiente para que o teste possa interagir com um banco de dados real.

  * Criar o endpoint /status: Um endpoint na API que, ao ser acessado, ir√° utilizar o m√≥dulo database.js para verificar o status da conex√£o, provando que a integra√ß√£o entre a API e o banco est√° funcionando.




Encostando a m√£o no Protocolo HTTP üî•
Essa aula vai ser muito massa, porque eu e voc√™ vamos encostar a m√£o no protocolo HTTP e isso n√£o somente vai esclarecer na sua mente muita coisa sobre tudo o que existe na internet, como tamb√©m vai ser a base para conseguir entender de fato (ou revisitar) muita coisa importante como: cookies, cabe√ßalhos, status codes, mas tirando toda a magia de onde esses dados vem, e tudo isso vai colocar voc√™ um passo mais pr√≥ximo da senioridade, ou pelo menos, vai fazer voc√™ conseguir ter conversas s√©rias, muito mais avan√ßadas e certeiras quando o contexto pedir por uma pessoa que tenha maturidade e experi√™ncia nesse assunto.

Anota√ß√µes:

O objetivo desta aula √© remover a "magia" do funcionamento da internet, entendendo na pr√°tica como o protocolo HTTP funciona. Esse conhecimento √© a base para dominar t√≥picos como APIs, cabe√ßalhos e status codes, e √© um passo fundamental para a senioridade t√©cnica.

1. O Papel das Interfaces e Abstra√ß√µes
API (Interface de Programa√ß√£o de Aplica√ß√µes): O princ√≠pio fundamental √© que "tudo √© uma interface". Seja uma interface de usu√°rio (gr√°fica) ou uma interface program√°vel (API), o objetivo √© o mesmo.

Abstra√ß√£o: Interfaces s√£o uma forma de abstra√ß√£o. Elas nos permitem usar uma funcionalidade sem precisar conhecer os detalhes de sua implementa√ß√£o interna. Elas definem um "contrato" de como interagir com um sistema.

2. Criando um Endpoint de API com Next.js
File-based Routing: No Next.js, o roteamento √© baseado em arquivos. Ao criar um arquivo dentro da pasta /pages/api/, ele automaticamente se torna um endpoint de API p√∫blico.

Exemplo (/pages/api/status.js): Um arquivo que exporta uma fun√ß√£o se torna um "ponto final" onde um cliente pode fazer uma requisi√ß√£o.

``` JavaScript

// A fun√ß√£o recebe dois objetos principais:
// request: Cont√©m os dados da requisi√ß√£o que chega.
// response: Cont√©m os m√©todos para construir e enviar a resposta.
function status(request, response) {
  // .status(200) define o HTTP Status Code para "OK".
  // .json({}) envia uma resposta no formato JSON.
  response.status(200).json({ status: "ok" });
}

export default status;

```

3. A Diferen√ßa entre .send() e .json()
O m√©todo .send() envia os dados, mas n√£o especifica o tipo de conte√∫do ou o charset.

O m√©todo .json() √© mais inteligente: ele automaticamente define o cabe√ßalho (Header) da resposta para Content-Type: application/json; charset=utf-8, informando ao cliente como interpretar os dados recebidos.

4. "Encostando a M√£o" no HTTP com curl
curl √© uma ferramenta de linha de comando para fazer requisi√ß√µes HTTP, permitindo ver a comunica√ß√£o "crua" entre cliente e servidor.

Comando: curl http://localhost:3000/api/status --verbose (ou -v).

A flag --verbose: Revela todos os detalhes da transa√ß√£o HTTP que normalmente ficam ocultos.

> (Request): Mostra os cabe√ßalhos que o seu cliente (curl) enviou para o servidor.

< (Response): Mostra os cabe√ßalhos que o servidor enviou de volta como resposta.

* (Curl Internals): Mostra informa√ß√µes sobre o processo de conex√£o que o curl est√° executando.

Usar o curl --verbose √© a forma pr√°tica de ver os cabe√ßalhos (como o Content-Type) e os status codes (como o 200) em a√ß√£o, transformando teoria em conhecimento concreto.



N√£o √© magia! (√© Protocolo)
Eu sugiro voc√™ ter um √∫nico objetivo com estas aulas mais recentes, que √© acreditar que, na area de tecnologia ou na programa√ß√£o num geral, n√£o existe magia... n√£o existe mesmo! Toda informa√ß√£o est√° em algum lugar e voc√™ pode n√£o conhecer esse lugar e naturalmente assumir que √© um local m√°gico, mas n√£o √©.

Ent√£o nesta aula n√≥s iremos cavucar um pouco mais o Protocolo HTTP na procura de informa√ß√µes que muitas pessoas encaram como "m√°gicas" üí™

Anota√ß√µes:

O objetivo √© provar que n√£o existe "magia" em tecnologia. Toda informa√ß√£o est√° em algum lugar, e entender onde ela est√° √© o que diferencia um profissional. Nesta aula, o foco √© entender como um servidor compartilhado sabe qual site deve entregar para o cliente.

1. O Problema: Um Servidor, V√°rios Sites (Virtual Hosts)

Servidor Simples: No passado, um √∫nico endere√ßo de IP geralmente correspondia a um √∫nico site. Acessar o IP abria o site.

Virtual Host (Servidor Compartilhado): Hoje, √© comum que um √∫nico servidor (com um s√≥ IP) hospede centenas ou milhares de sites diferentes (como os da Vercel).

A "Magia": Se v√°rios dom√≠nios (ex: siteA.com, siteB.com) apontam para o mesmo IP, como o servidor sabe qual deles o usu√°rio quer ver?

2. A Solu√ß√£o: O Cabe√ßalho Host do Protocolo HTTP
A resposta n√£o √© m√°gica, est√° dentro do protocolo HTTP.

Quando voc√™ acessa um site, seu navegador primeiro usa o DNS para descobrir o IP do servidor daquele dom√≠nio.

Em seguida, ele envia uma requisi√ß√£o HTTP para esse IP. Dentro dessa requisi√ß√£o, existe um cabe√ßalho (header) chamado Host.

O valor do cabe√ßalho Host √© o dom√≠nio que voc√™ digitou (ex: Host: siteA.com).

O servidor da Vercel (ou qualquer outro com Virtual Hosts) l√™ este cabe√ßalho Host para saber qual dos m√∫ltiplos sites que ele hospeda deve ser entregue ao cliente.

3. Provando o Conceito com curl

Podemos simular esse processo manualmente para provar que √© o cabe√ßalho Host que comanda a opera√ß√£o.

Comando: curl ip_do_servidor --insecure --verbose --header 'Host: nome_do_site.com'

An√°lise do Comando:

curl ip_do_servidor: Faz a requisi√ß√£o diretamente ao IP do servidor, pulando a etapa do DNS.

--header 'Host: nome_do_site.com': Aqui est√° o segredo. Estamos manualmente adicionando o cabe√ßalho HTTP, dizendo ao servidor qual site queremos acessar.

--insecure: Necess√°rio porque o certificado de seguran√ßa (HTTPS) geralmente est√° associado ao dom√≠nio, e n√£o ao IP. Sem essa flag, o curl daria um erro de certificado.

--verbose: Exibe todos os detalhes da requisi√ß√£o e da resposta, permitindo ver o cabe√ßalho Host que enviamos em a√ß√£o.

Este exerc√≠cio pr√°tico demonstra que a sele√ß√£o do site n√£o √© m√°gica, mas sim o resultado da leitura de uma informa√ß√£o clara e acess√≠vel enviada atrav√©s do protocolo HTTP.







Versionamento de API e Endpoint "/status"
A aula de hoje tem muito mais conte√∫dos sobre API e HTTP, mas ela um objetivo muito claro e que j√° est√° super encaminhado, que √© completar a tarefa Criar endpoint /status, e em cima disto iremos aprender sobre Versionamento de API e Breaking Changes ü§ù

Anota√ß√µes:

Evoluir uma API √© um processo delicado. √â preciso adicionar novas funcionalidades sem quebrar a integra√ß√£o para os clientes que j√° a utilizam. A chave para isso √© uma boa estrat√©gia de versionamento.

1. O Contrato da API: Breaking vs. Non-Breaking Changes
Non-Breaking Change: Uma mudan√ßa aditiva, como adicionar uma nova propriedade √† resposta. O consumidor deve estar preparado para receber mais dados do que o esperado sem quebrar.

Breaking Change: Uma mudan√ßa que quebra a compatibilidade com vers√µes anteriores (ex: renomear ou remover uma propriedade). O fornecedor da API precisa de uma estrat√©gia para introduzir essas mudan√ßas.

Estrat√©gias de Versionamento: As mais comuns s√£o via URL (URI Path Versioning) ou via cabe√ßalho HTTP (Header Versioning). A aula foca na primeira.

2. Implementando o Versionamento via URL (Path Versioning)
A abordagem √© criar um "prefixo" na URL que indica a vers√£o da API.

Estrutura de Pastas:

Dentro da pasta /pages/api, cria-se uma pasta para a vers√£o: /v1.

A l√≥gica do endpoint (o antigo status.js) √© movida para dentro da nova estrutura, resultando em: pages/api/v1/status/index.js.

Resultado: O endpoint, que antes era /api/status, agora se torna /api/v1/status, indicando claramente que esta √© a vers√£o 1.

3. Testando o Endpoint Versionado
√â crucial garantir que a nova URL funcione como esperado.

Organiza√ß√£o dos Testes: A estrutura de pastas dos testes de integra√ß√£o (/integration) deve espelhar a da API: integration/api/v1/status/get.test.js.

C√≥digo do Teste (get.test.js):

``` JavaScript

// No protocolo HTTP, √© preciso especificar o m√©todo (GET, POST, etc.)
test("GET to /api/v1/status should return 200", async () => {
  const response = await fetch("http://localhost:3000/api/v1/status");
  expect(response.status).toBe(200);
});

Observa√ß√£o sobre async/await:
A fun√ß√£o fetch realiza uma opera√ß√£o de rede, que √© ass√≠ncrona (n√£o acontece instantaneamente). Ela retorna uma Promise (promessa) de uma resposta futura.
await √© usado para pausar a execu√ß√£o da fun√ß√£o at√© que a Promise do fetch seja resolvida (ou seja, at√© a resposta chegar).

Toda fun√ß√£o que usa await precisa ser declarada como async.

4. Limpeza do Projeto
"Deletar a pasta de teste unit√°rios e o arquivo da calculadora": Este passo simboliza a evolu√ß√£o do projeto. O foco sai de exemplos did√°ticos (testes unit√°rios de uma calculadora) e passa para testes mais realistas e de maior valor para o projeto: os testes de integra√ß√£o da API.






üöó Pista R√°pida: Dia 17
Al√©m de conversarmos sobre tudo que foi feito no Dia 17, como as 3 partes que eu considero na escolha de um Banco de Dados, entender o motivo do Docker ter "dominado" o mundo das virtualiza√ß√µes, depois como subir e se conectar a uma inst√¢ncia de Postgres de forma local utilizando o Docker Compose, al√©m de tudo isso, eu passo mais um pouco da minha vis√£o sobre o que faz um s√™nior ser um s√™nior na nossa √°rea üí™

Qual Banco de Dados escolher?
Eu vou come√ßar essa aula de um jeito estranho mas... e se eu te falar que talvez eu fiz a pior escolha de qual banco de dados usar para o TabNews e eu n√£o me arrependo nenhum pouco? üî•

Link para issue
Segue abaixo o link para a issue que eu comentei no v√≠deo:

https://github.com/filipedeschamps/tabnews.com.br/issues/61

Anota√ß√µes: 

A aula aborda a escolha de um banco de dados n√£o como uma busca pela ferramenta "perfeita", mas como uma decis√£o estrat√©gica. A reflex√£o sobre a "pior escolha" para o TabNews, da qual n√£o h√° arrependimento, ilustra que a melhor tecnologia √© aquela que resolve o problema e que a equipe domina.

Os 3 Componentes na Escolha de um Banco de Dados
Para tomar uma decis√£o "Future-Proof" (√† prova de futuro), √© preciso pensar em tr√™s camadas:

O SGBD (Sistema de Gerenciamento de Banco de Dados): √â a escolha do banco de dados em si.

Tipos: Relacional (SQL), N√£o Relacional (NoSQL), S√©rie Temporal, Espacial, etc.

D√∫vida Comum: A decis√£o mais frequente no mercado hoje √© entre SQL vs. NoSQL.
Exemplo: PostgreSQL (SQL).

A Forma de Consulta (Query): Como a sua aplica√ß√£o vai "conversar" com o banco de dados.

Com ORM (Object-Relational Mapper): Ferramentas que mapeiam tabelas do banco para objetos no seu c√≥digo, abstraindo a escrita de SQL.
Exemplos: Sequelize, Prisma.

Sem ORM (Driver Nativo): Usar uma biblioteca para se conectar e escrever as consultas SQL diretamente.
Exemplo: node-postgres (pacote pg).

As Migra√ß√µes (Migrations): √â o sistema de versionamento para a estrutura (schema) do seu banco de dados.

Fun√ß√£o: S√£o arquivos com instru√ß√µes que modificam o banco de dados de forma controlada e rastre√°vel (ex: criar uma tabela, adicionar uma coluna).
Exemplo de Ferramenta: node-pg-migrate.

Outros Conceitos Abordados
Docker: Foi mencionado como a ferramenta que "dominou" a virtualiza√ß√£o por facilitar a cria√ß√£o de ambientes de desenvolvimento consistentes, como subir uma inst√¢ncia local do Postgres via Docker Compose.

A Vis√£o S√™nior: A maturidade profissional n√£o est√° em sempre escolher a tecnologia da moda, mas em entender as consequ√™ncias de cada escolha (SGBD, Query, Migrations) e optar por um conjunto de ferramentas que a equipe consiga manter e evoluir com seguran√ßa.






Por que o Docker dominou o mundo?
Eu vim de uma √©poca que me d√≥i lembrar como que era configurar os servi√ßos num ambiente de desenvolvimento local, porque toda hora algo m√°gico acontecia üòÖ E nesta Pista Lenta vamos conferir a evolu√ß√£o deste assunto, at√© entrarmos na √©poca dos containers.

Anota√ß√µes:

Configurar ambientes de desenvolvimento era um processo fr√°gil e inconsistente, conhecido pelo problema do "funciona na minha m√°quina". O Docker resolveu isso de uma forma muito mais eficiente que as solu√ß√µes anteriores.

1. O Problema Original: A Inconsist√™ncia do "Host"
No passado, o mesmo tutorial ou c√≥digo poderia falhar em m√°quinas diferentes por pequenas varia√ß√µes no ambiente local (o "Host"), como:

  * Hardware diferente
  * Sistema Operacional (vers√£o, patches de seguran√ßa)
  * Softwares instalados (antiv√≠rus, outros programas)
  * Vers√£o da linguagem de programa√ß√£o
  * At√© mesmo o fuso hor√°rio

2. Primeira Solu√ß√£o: M√°quinas Virtuais (VMs)
O que s√£o: As VMs surgiram para criar um ambiente padronizado, emulando uma m√°quina completa (hardware e sistema operacional) dentro da sua m√°quina f√≠sica.

Problema: Apesar de resolverem a inconsist√™ncia, as VMs eram muito pesadas, consumindo grande quantidade de disco, mem√≥ria e processamento. Ferramentas como o Vagrant tentaram facilitar seu uso, mas o problema de performance continuava.

3. A Revolu√ß√£o: Cont√™ineres e o Docker
O Docker introduziu uma abordagem mais inteligente e leve, baseada em dois recursos do Kernel do Linux:

Namespaces: Permitem isolar os processos. Um processo rodando em um cont√™iner n√£o consegue "enxergar" ou interferir nos processos de outro cont√™iner ou do pr√≥prio Host.

cgroups: Permitem controlar e limitar os recursos (CPU, mem√≥ria, etc.) que cada processo pode consumir.

O Docker empacotou essas tecnologias em uma ferramenta f√°cil de usar.

Compara√ß√£o dos Modelos: VM vs. Cont√™iner
A grande vantagem do Docker fica clara ao comparar as "camadas" de cada modelo:

Modelo com M√°quina Virtual (VM):

M√°quina (Host)
SO (Host)
Virtualizador (Hypervisor)
SO Convidado (Guest OS) <- Camada pesada e redundante
Aplica√ß√£o / Banco de Dados

Modelo com Cont√™iner (Docker):

M√°quina (Host)
SO (Host)
Container Engine (Docker)
Aplica√ß√£o / Banco de Dados

A Diferen√ßa Chave: Cont√™ineres compartilham o Kernel do Sistema Operacional do Host. Eles n√£o precisam carregar um sistema operacional inteiro como as VMs, o que os torna drasticamente mais leves, r√°pidos e eficientes em recursos. Essa efici√™ncia √© o principal motivo pelo qual o Docker dominou o mundo da virtualiza√ß√£o e desenvolvimento.






Subir Banco de Dados (Local)
A aula de hoje vai ser bastante pr√°tica, pois iremos usar o docker compose para subir um Banco de Dados na sua vers√£o Local üéâ

Links
P√°gina oficial do Postgres no Docker Hub

Anota√ß√µes:

O objetivo desta aula pr√°tica √© utilizar o Docker Compose para criar e gerenciar um cont√™iner com um banco de dados PostgreSQL, simplificando radicalmente a configura√ß√£o do ambiente de desenvolvimento local.

1. Conceitos Fundamentais
Dockerfile vs. Imagem vs. Cont√™iner:

Dockerfile: √â o "c√≥digo-fonte", um arquivo de texto com instru√ß√µes para construir uma imagem.

Imagem: √â o "bin√°rio" ou "pacote" gerado a partir de um Dockerfile. Fica salvo e pode ser compartilhado.

Cont√™iner: √â uma inst√¢ncia em execu√ß√£o de uma imagem.

Docker Hub: √â um reposit√≥rio p√∫blico de imagens Docker, similar ao GitHub para c√≥digo. √â de l√° que vamos baixar a imagem oficial do postgres.

Docker Compose: Uma ferramenta para definir e rodar aplica√ß√µes Docker com m√∫ltiplos cont√™ineres (como um banco de dados e um Mailcatcher) a partir de um √∫nico arquivo de configura√ß√£o.

2. Passos Pr√°ticos para Subir o Banco de Dados
Passo 1: Verificar as Ferramentas
Antes de come√ßar, verifique se o Docker e o Docker Compose est√£o instalados com os comandos:

``` Bash

docker --version
docker-compose version

```

Passo 2: Criar o Arquivo de Configura√ß√£o
Crie um arquivo na raiz do seu projeto chamado compose.yaml (ou docker-compose.yml).

Passo 3: Definir o Servi√ßo do Banco de Dados
Dentro do arquivo compose.yaml, defina o servi√ßo do banco de dados:

``` YAML

services:
  database:
    image: "postgres:16-alpine"
    environment:
      # Define a senha do superusu√°rio do Postgres
      POSTGRES_PASSWORD: "local_password"

```

services: Inicia a declara√ß√£o dos cont√™ineres que o Compose vai gerenciar.

database: Um nome que voc√™ escolhe para o seu servi√ßo de banco de dados.

image: "postgres:16-alpine": Especifica qual imagem usar do Docker Hub.

postgres: O nome da imagem oficial.

16-alpine: A "tag", indicando a vers√£o 16 do Postgres na sua variante "alpine", que √© mais leve.

environment: Permite passar vari√°veis de ambiente para dentro do cont√™iner. POSTGRES_PASSWORD √© uma vari√°vel obrigat√≥ria exigida pela imagem do Postgres para a configura√ß√£o inicial.

Passo 4: Iniciar o Cont√™iner
No terminal, na mesma pasta onde est√° o arquivo compose.yaml, execute o comando:

``` Bash

docker compose up

```

Este comando ir√° ler o arquivo, baixar a imagem do Postgres (se ainda n√£o tiver), criar e iniciar o cont√™iner do banco de dados com as configura√ß√µes definidas. Ao final do processo, voc√™ ter√° um banco de dados PostgreSQL rodando localmente, isolado e pronto para ser usado pela sua aplica√ß√£o.




Se conectando no Banco de Dados (Local)
Eu deixei voc√™ na cara do gol na aula anterior, com o container rodando e servindo o Postgres, mas n√£o sendo poss√≠vel se conectar nele. E olha s√≥ que engra√ßado, a aula de hoje vai come√ßar tentando se conectar nele mesmo assim para entender de verdade porque n√£o √© poss√≠vel, e por fim, se conectar nele com sucesso üéâ

Link para o commit feito na aula
add compose config file with database service

Anota√ß√µes:

O tema central √© que "conhecer o problema √© conhecimento". Entender por que algo falha √© uma etapa crucial do aprendizado. Nesta aula, o objetivo √© rodar um cont√™iner de banco de dados e conseguir se conectar a ele a partir da sua m√°quina (Host).

1. Rodando o Cont√™iner e Verificando seu Estado
Subindo o Cont√™iner: O comando docker compose up inicia os servi√ßos. Por padr√£o, ele "prende" o seu terminal.

Para rodar em segundo plano (detached mode), use: docker compose up -d.

Verificando Cont√™ineres:
docker ps: Lista os cont√™ineres que est√£o em execu√ß√£o.

docker ps -a (ou --all): Lista todos os cont√™ineres, inclusive os que pararam.

Inspecionando Logs: Se algo der errado, os logs s√£o o primeiro lugar para procurar.

docker logs nome_do_cont√™iner: Exibe a sa√≠da de um cont√™iner espec√≠fico.

Exit Codes: Assim como os Status Codes HTTP (200=sucesso, 500=erro), os cont√™ineres usam Exit Codes para indicar seu estado final.

Exit Code 0: O processo terminou com sucesso.
Exit Code diferente de 0: O processo terminou com erro.

2. A Tentativa de Conex√£o (e o Erro Esperado)
O objetivo √© se conectar ao Postgres dentro do cont√™iner usando o cliente psql.

Instalar o Cliente: Primeiro, √© preciso ter o cliente do PostgreSQL na m√°quina Host.

``` Bash

sudo apt update
sudo apt install postgresql-client

```

Tentar a Conex√£o: O comando psql precisa saber o endere√ßo, porta e credenciais.
 
``` Bash

psql --host=localhost --port=5432 --username=postgres

```

O Problema: Este comando vai falhar. O motivo √© que, por padr√£o, o Docker n√£o exp√µe as portas de um cont√™iner para a m√°quina Host. O "mundo de fora" n√£o consegue acessar o que est√° rodando "l√° dentro".

3. A Solu√ß√£o: Expor a Porta no compose.yaml
Para corrigir o problema, √© preciso mapear uma porta da sua m√°quina (Host) para uma porta do cont√™iner.

Adicionar ao compose.yaml:

``` YAML

services:
  database:
    # ... outras configura√ß√µes ...
    ports:
      # Mapeia a porta 5432 do Host para a 5432 do Cont√™iner
      - "5432:5432"

```

Recriar o Cont√™iner: As mudan√ßas no compose.yaml s√≥ t√™m efeito se o cont√™iner for recriado.

``` Bash

# Op√ß√£o 1: Parar tudo e subir de novo
docker compose down
docker compose up -d

# Op√ß√£o 2: For√ßar a recria√ß√£o diretamente
docker compose up -d --force-recreate

```

Sucesso! Agora o comando psql ir√° funcionar. Voc√™ pode testar com uma consulta simples (SELECT 1 + 1;) e sair com \q.

4. Organiza√ß√£o e Boas Pr√°ticas
Parar os Servi√ßos: Para parar e remover os cont√™ineres, use docker compose down.

Organizar Arquivos: Mova o compose.yaml para uma pasta dedicada, como infra/.

Usar Arquivo Espec√≠fico: Ao rodar os comandos, especifique o caminho do arquivo.

``` Bash

docker compose -f infra/compose.yaml up

```










üöó Pista R√°pida: Dia 18
Como sempre, vamos passar rapidamente pelas principais coisas que aconteceram no Dia 18 (e aconteceram muitas coisas), mas tem algo em especial que eu n√£o deixei claro em nenhuma Pista Lenta que eu quero falar aqui nessa Pista R√°pida e que aconteceu 25 vezes üòç

Criar m√≥dulo "database.js"
Nesta aula iremos criar o m√≥dulo database.js que √© uma abstra√ß√£o da nossa infraestrutura e que vai ser respons√°vel por abrir conex√£o com o Banco de Dados e enviar queries pra ele. Para isto, vamos instalar o m√≥dulo pg na vers√£o 8.11.3 ü§ù

Coment√°rio destaque ‚≠êÔ∏è
Depois de ver a aula, sugiro ler este coment√°rio que fiz sobre a d√∫vida de outro aluno, pois pode ajudar a clarear alguns pontos importantes sobre a utilidade do database.js üí™

Anota√ß√µes:

O objetivo da aula √© criar uma abstra√ß√£o para o acesso ao banco de dados. Em vez de espalhar a l√≥gica de conex√£o por todo o c√≥digo, ela ser√° centralizada em um √∫nico m√≥dulo (database.js), tornando a aplica√ß√£o mais limpa, segura e f√°cil de manter.

1. Prepara√ß√£o do Ambiente
Instalar o Driver do Postgres: Para que o Node.js possa se comunicar com o PostgreSQL, √© preciso instalar o driver correspondente.

``` Bash

npm install pg@8.11.3

``` 

Iniciar os Servi√ßos:
Subir o banco de dados em segundo plano:

``` Bash

docker compose -f infra/compose.yaml up -d

``` 

Iniciar a aplica√ß√£o em modo de desenvolvimento:

``` Bash

npm run dev

``` 

Ajuste nos Testes: Para garantir que todos os testes sejam re-executados ao salvar um arquivo, o script de teste no package.json √© alterado para:

``` JSON

"test:watch": "jest --watchAll"

``` 

2. Construindo o M√≥dulo database.js
Dentro da pasta infra, √© criado o arquivo database.js. Ele ser√° o √∫nico lugar do sistema que sabe como se conectar e executar comandos no banco de dados.

C√≥digo do infra/database.js:

``` JavaScript

import { Client } from 'pg';

async function query(queryObject) {
  const client = new Client({
    host: 'localhost',
    port: 5432,
    user: 'postgres',
    database: "postgres",
    password: "local_password"
  });
  
  await client.connect();
  const result = await client.query(queryObject);
  await client.end();
  
  return result;
}

export default {
  query: query,
};

``` 

new Client({...}): Cria uma nova inst√¢ncia do cliente Postgres com as credenciais de acesso, que devem ser as mesmas definidas no compose.yaml.

client.connect(): Abre a conex√£o com o banco de dados.

client.query(): Executa a consulta SQL recebida.

client.end(): Fecha a conex√£o. Este √© um passo crucial para n√£o deixar conex√µes abertas desnecessariamente.

3. Utilizando o M√≥dulo
O endpoint /api/v1/status/index.js √© modificado para usar a nova abstra√ß√£o.

``` JavaScript

import database from "../../../../infra/database.js";

// ... dentro da fun√ß√£o do endpoint ...
const result = await database.query('SELECT 1 + 1 as sum;');
console.log(result.rows); // Exibe o resultado da consulta

``` 

O Grande Benef√≠cio: Agora, o endpoint de status (e qualquer outro) n√£o precisa saber nada sobre o pacote pg ou sobre como abrir e fechar conex√µes. 

Ele apenas chama database.query(). Se no futuro for preciso trocar o driver, as credenciais ou a l√≥gica de conex√£o, a mudan√ßa ser√° feita em um √∫nico lugar: o arquivo database.js.



A import√¢ncia das Vari√°veis de Ambiente
Quando eu realmente entendi o poder e a simplicidade das Vari√°veis de Ambiente, o meu c√©rebro deu alguns cliques muito importantes. Um deles foi de sempre que poss√≠vel deixar a camada da aplica√ß√£o stateless (sem estado) e isso se conecta perfeitamente com v√°rias formas profissionais de se construir e escalar uma aplica√ß√£o üí™

Anota√ß√µes:

O entendimento de Vari√°veis de Ambiente √© um "clique" fundamental para o desenvolvimento de software profissional, pois elas s√£o a chave para criar aplica√ß√µes flex√≠veis, escal√°veis e, principalmente, Stateless (sem estado).

1. O Que S√£o Vari√°veis de Ambiente?
S√£o configura√ß√µes externas que s√£o "injetadas" em uma aplica√ß√£o dependendo do ambiente onde ela est√° rodando. Em vez de ter dados fixos no c√≥digo (hardcoded), a aplica√ß√£o os l√™ do seu ambiente.

O Problema que Resolvem: Uma configura√ß√£o que funciona em localhost (ex: senha do banco de dados local) n√£o vai funcionar em homologa√ß√£o ou produ√ß√£o. Vari√°veis de Ambiente permitem que o mesmo c√≥digo funcione em todos os lugares, apenas mudando os valores de acordo com o contexto.

2. O Objetivo: Uma Aplica√ß√£o "Stateless"
Stateless (Sem Estado): √â um princ√≠pio de arquitetura onde a camada da aplica√ß√£o n√£o armazena nenhuma informa√ß√£o persistente. Ela processa uma requisi√ß√£o e esquece. Todo o "estado" (dados de usu√°rios, sess√µes, etc.) √© delegado a servi√ßos externos.

Separa√ß√£o de Camadas: A ideia √© separar a camada de Persist√™ncia (o banco de dados) da camada de Aplica√ß√£o.

Antes: Backend monol√≠tico (Interface + Aplica√ß√£o + Persist√™ncia)

Depois: Aplica√ß√£o (Interface + L√≥gica) <-> Servi√ßo de Banco de Dados

3. Como as Vari√°veis de Ambiente Conectam Tudo
As Vari√°veis de Ambiente s√£o a "cola" que permite √† aplica√ß√£o stateless encontrar e se comunicar com os servi√ßos de persist√™ncia.

A aplica√ß√£o √© programada para buscar as credenciais e endere√ßos (como host, usu√°rio e senha do banco) a partir das vari√°veis de ambiente.

Em localhost: O ambiente fornece as vari√°veis com os dados do seu banco de dados local.

Em Produ√ß√£o: O ambiente de produ√ß√£o (servidor, cont√™iner) fornece as vari√°veis com os dados do banco de dados de produ√ß√£o.

Essa abordagem torna a aplica√ß√£o extremamente port√°til e escal√°vel. √â poss√≠vel subir m√∫ltiplas inst√¢ncias id√™nticas da mesma aplica√ß√£o, e cada uma se conectar√° ao banco de dados correto simplesmente lendo as vari√°veis do ambiente em que foi iniciada.



Vari√°veis de Ambiente no C√≥digo
Qual a rela√ß√£o entre Vari√°veis de Ambiente, process, env e o que entra dentro do seu c√≥digo? Vamos ver tudo isso dentro dessa aula e deixar sua aplica√ß√£o 100% stateless üí™

Anota√ß√µes:

O objetivo √© externalizar todas as configura√ß√µes sens√≠veis ou que mudam entre ambientes (desenvolvimento, produ√ß√£o), tornando a aplica√ß√£o 100% stateless e segura.

1. Acessando Vari√°veis de Ambiente no Node.js
process.env: Em Node.js, todas as vari√°veis de ambiente do processo atual ficam dispon√≠veis em um objeto global chamado process.env.

Aplica√ß√£o no C√≥digo: Para usar uma vari√°vel, basta acess√°-la como uma propriedade deste objeto. No arquivo database.js, os valores fixos ("hardcoded") s√£o substitu√≠dos:

Antes:

``` JavaScript

password: "local_password",

```

Depois:

``` JavaScript

password: process.env.POSTGRES_PASSWORD,

``` 

2. Como Fornecer as Vari√°veis para a Aplica√ß√£o
Existem duas formas principais para o ambiente de desenvolvimento local:

M√©todo 1: Pela Linha de Comando
Voc√™ pode definir a vari√°vel diretamente no comando que inicia a aplica√ß√£o. Ela ser√° v√°lida apenas para a execu√ß√£o daquele comando.

``` Bash

POSTGRES_PASSWORD=local_password npm run dev

``` 

Dica de Hist√≥rico: Iniciar um comando com um espa√ßo em branco ("comando") geralmente evita que ele seja salvo no hist√≥rico do terminal (history), √∫til para n√£o expor senhas.

M√©todo 2: Usando um Arquivo .env (com dotenv)
Esta √© a abordagem mais comum e organizada para desenvolvimento local.

Criar o arquivo .env: Na raiz do projeto, crie um arquivo chamado .env. Este arquivo nunca deve ser enviado para o reposit√≥rio (Git), pois cont√©m informa√ß√µes sens√≠veis.

Adicionar as Vari√°veis: Dentro do .env, liste todas as vari√°veis de configura√ß√£o no formato CHAVE=VALOR.

``` Code snippet

POSTGRES_HOST=localhost
POSTGRES_PORT=5432
POSTGRES_USER=postgres
POSTGRES_DB=postgres
POSTGRES_PASSWORD=local_password

``` 

(Nota: Para que isso funcione, a biblioteca dotenv precisa ser instalada e configurada no ponto de entrada da sua aplica√ß√£o).

3. Resultado Final no database.js
Com as vari√°veis definidas no ambiente (seja via comando ou .env), o c√≥digo do database.js fica limpo, seguro e flex√≠vel, lendo todas as suas configura√ß√µes do process.env:

``` JavaScript

new Client({
  host: process.env.POSTGRES_HOST,
  port: process.env.POSTGRES_PORT,
  user: process.env.POSTGRES_USER,
  database: process.env.POSTGRES_DB,
  password: process.env.POSTGRES_PASSWORD,
});

``` 





Vari√°veis de Ambiente no Docker Compose
Como fazer para evitar de ter Vari√°veis de Ambiente duplicadas no arquivo compose.yaml, no arquivo databse.js e fazer tudo puxar do .env? √â isso o que iremos ver nesta aula, fora se deparar com um mist√©rio... vamos ver se voc√™ sabe a resposta ü§ù

Mist√©rio: Por qu√™ o Banco de Dados rodou?
Por que no minuto 02:22 da aula, ao trocar a Vari√°vel de Ambiente de POSTGRES_DATABASE para POSTGRES_DB no arquivo .env, a conex√£o com o Banco de Dados continuou funcionando, se o database.js estava pedindo ainda pela antiga Vari√°vel de Ambiente POSTGRES_DATABASE? Voc√™ vai precisar investigar para encontrar esta resposta üí™

Coment√°rio em destaque
Caso queira saber qual a resposta, sugiro ler esse coment√°rio que est√° bastante completo ü§ù

Link para o commit feito na aula
add database.js and .env files

Anota√ß√µes: 
O objetivo desta aula √© eliminar a duplica√ß√£o de configura√ß√µes, fazendo com que tanto a aplica√ß√£o (database.js) quanto a infraestrutura (compose.yaml) utilizem o arquivo .env como a √∫nica fonte da verdade para as vari√°veis de ambiente.

1. O Problema: Configura√ß√µes Duplicadas
Manter as mesmas vari√°veis de ambiente (como a senha do banco) hardcoded no compose.yaml e tamb√©m sendo lidas via process.env na aplica√ß√£o √© ineficiente e propenso a erros.

2. A Solu√ß√£o: Usar env_file no Docker Compose
O Docker Compose possui uma diretiva chamada env_file que o instrui a carregar as vari√°veis de ambiente para um servi√ßo diretamente de um arquivo, como o .env.

Passos da Implementa√ß√£o:

Padronizar Vari√°veis: Garanta que os nomes das vari√°veis estejam consistentes. Por exemplo, altere POSTGRES_DATABASE para POSTGRES_DB tanto no .env quanto no database.js.

Atualizar o compose.yaml: Remova as vari√°veis de ambiente definidas manualmente e aponte para o arquivo .env.

``` YAML

services:
  database:
    image: "postgres:16-alpine"
    # A se√ß√£o "environment" foi removida
    env_file:
      - "../.env" # Carrega as vari√°veis do .env na raiz do projeto
    ports:
      - "5432:5432"

``` 

Aplicar as Mudan√ßas: Reinicie os cont√™ineres para que a nova configura√ß√£o seja aplicada.

``` Bash

docker compose -f infra/compose.yaml up -d --force-recreate

``` 

3. O Mist√©rio: Por que a Conex√£o Continuou Funcionando?
O Cen√°rio: Em um momento da aula, o .env foi alterado para POSTGRES_DB, mas o database.js ainda esperava a vari√°vel antiga (POSTGRES_DATABASE), que agora estava indefinida. Mesmo assim, a conex√£o com o banco de dados funcionou.

A Explica√ß√£o (N√£o √© magia!):
Persist√™ncia de Dados do Docker: Por padr√£o, o Docker cria um "volume" para o cont√™iner do Postgres, onde os dados do banco s√£o salvos. Isso evita que voc√™ perca tudo ao reiniciar o cont√™iner.

Inicializa√ß√£o do Postgres: As vari√°veis POSTGRES_DB e POSTGRES_USER s√£o usadas pela imagem do Postgres apenas na primeira vez que o cont√™iner √© criado, para inicializar o banco de dados.

Reutiliza√ß√£o do Volume: Ao reiniciar o cont√™iner (docker compose up), ele detectou o volume com os dados j√° existentes e simplesmente ignorou as vari√°veis de inicializa√ß√£o (POSTGRES_DB), pois o banco j√° estava criado. A conex√£o continuou funcionando com a base de dados que j√° existia.

4. Pr√≥ximos Passos no Fluxo de Trabalho
Commit: Ap√≥s as altera√ß√µes, salvar o progresso no Git (git commit).

Atualizar a Issue: Criar uma nova tarefa no quadro de trabalho, como - [ ] Finalizar retorno do endpoint /status, para dar continuidade ao desenvolvimento.